[
{
	"uri": "https://tibcosoftware.github.io/getting-started/",
	"title": "Getting started",
	"tags": [],
	"description": "",
	"content": "Getting started How to get started with Project Flogo!\n"
},
{
	"uri": "https://tibcosoftware.github.io/",
	"title": "Project Flogo",
	"tags": [],
	"description": "",
	"content": "Project Flogo Docs and Tutorials for an Open Source ecosystem for event-driven apps\nGet started...\nI\u0026#39;m an App Developer!\nI\u0026#39;m a Go Developer!\nI need help!\nAs an App Developer you might want to try...\nOur quickstart\nGetting started with the Web UI\nCheck out some labs\nAs a Go Developer you might want to try...\nBuilding your first activity\nMapping some fields\nDeploy a Flogo app to AWS Lambda\nIf you have any questions, feel free to\rpost an issue\rand tag it as a question, email flogo-oss at tibco dot com or chat\rwith the team and community in:\rCome join our Gitter channel to talk all things Flogo!\nJoin this Gitter channel for developer questions!\n"
},
{
	"uri": "https://tibcosoftware.github.io/getting-started/quickstart/",
	"title": "Quickstart",
	"tags": [],
	"description": "",
	"content": "We think it is awesome that you want to get started with Project Flogo! To get started you don\u0026rsquo;t even need to install anything other than Docker!\nTimers are great to schedule stuff, and a great way to learn new technology! Use this lab to get familiar with some of the concepts of Flogo! Hello World! This lab will walk you through building your first API with Project Flogo After you\u0026rsquo;re done with these samples, why not check out the other labs we have for you!\n"
},
{
	"uri": "https://tibcosoftware.github.io/getting-started/getting-started-webui/",
	"title": "Flogo Web UI",
	"tags": [],
	"description": "",
	"content": "Getting Started For an overview of how to get started, check out the Quickstart guide\nFetching and starting the Web UI To get started with the latest version of the Flogo Web UI, you have two options:\nPull the source from the project-flogo/flogo-web repository on GitHub (follow the instructions in the README to build and run the UI). Fetch the latest Docker image by executing the following command in your terminal window: docker run -it -p 3303:3303 flogo/flogo-docker:latest eula-accept\nLaunching the Web UI To launch Flogo WebUI simply open your favorite web browser, and navigate to http://localhost:3303 (if you\u0026rsquo;re using the Docker Hub version, otherwise use whatever port you specified when building and starting via source). You\u0026rsquo;ll see our mascot Flynn there to greet you!\nRestarting the Web UI docker container After the Docker container has been shutdown, you may wish to simply restart the same container instance, rather than creating a new instance via the docker run command. You can easily do this by issuing the docker start command and reference the previously running container id. You can find the container name and id by using the command docker ps -a and searching for the container with the image flogo/flogo-docker. Use the ID (or name) associated with the image to issue the docker start command. For example:\ndocker start b24e4b9f3fa5\n"
},
{
	"uri": "https://tibcosoftware.github.io/getting-started/getting-started-cli/",
	"title": "Flogo CLI",
	"tags": [],
	"description": "",
	"content": "Before you get started Before you can get started with the cli tools you need to make sure you have the Go programming language installed.\nFlogo makes use of Go Modules, as such, you\u0026rsquo;ll need to ensure that you have at least Go 1.14.\nDon\u0026rsquo;t forget to set your GOPATH variable and make sure that $GOPATH/bin is part of your path. (see here or here for more details)\nInstalling the cli tools Now that you\u0026rsquo;ve installed the Go programming language there are a few commands you can run to install the cli and make developing with the cli tools even easier\nFirst you\u0026rsquo;ll need to go install flogo by running go install github.com/project-flogo/cli/...@latest. This will fetch, build and install the Flogo CLI for your machine. If you want to update the CLI tools, you can run go install github.com/project-flogo/cli/...@latest to get the latest version.\n"
},
{
	"uri": "https://tibcosoftware.github.io/labs/",
	"title": "Labs",
	"tags": [],
	"description": "",
	"content": "Labs After getting up and running you might want to try your hand at some more advanced labs and tutorials. These labs provide you with a guides, tutorials and code samples and will help you work through building and deploying Flogo apps. The labs cover a wide range of topics like deploying to Kubernetes, using Flogo with the Serverless Framework and a bunch more! The colors of the cards have a meaning:\nFlogo CLI These labs have an emphasis on using the Flogo CLI to build apps\nFlogo CLI Project Flogo provides two different command-line interfaces and which you need depends on the task you need to execute. This tutorial covers the \u0026#39;flogo\u0026#39; command AWS Lambda Flogo has first class support for AWS Lambda. This tutorial covers building Lambda apps using the Flogo CLI Building activities Building new activities to extend the capabilities of Project Flogo is definitely not the most difficult thing on the planet. In fact, it\u0026#39;s rather easy to get you started! Building triggers Triggers make it possible for Flogo to get data. How do you get started building a trigger, though? Check this tutorial to build a simple trigger. Build using Go Cheesecakes are important! In fact, we believe perhaps the most important thing, right after Flogo. In this tutorial you\u0026#39;ll build a cheesecake service using the Go API. Streams: Aggregate Learn how to use the JSON DSL to build streaming pipelines using the power of Flogo. Streams: Filter Learn how to use the JSON DSL to build a simple streaming pipelines, using the power of Flogo, that filters out all zeros. Flogo Web UI These labs have an emphasis on using the Flogo Web UI to build apps\nTimers Timers are great to schedule stuff, and a great way to learn new technology! Use this lab to get familiar with some of the concepts of Flogo! Hello World Hello World! This lab will walk you through building your first API with Project Flogo Bookstore Who doesn\u0026#39;t like a good book? But what if you really need to get some information about a book first? In that case you build a Flogo app that uses Google APIs to that! Raspberry Pi Flogo runs perfectly on these small devices, and in this lab you\u0026#39;ll build a sample to read and write data to the GPIO pins of the device to control your home lights! AWS IoT A device shadow is a digital representation in the cloud that stores and retrieves current state information for a device using AWS IoT. Invoice Service Let\u0026#39;s build an invoiceservice! In this tutorial we\u0026#39;ll walk you through building an app with several community-driven activities and talks to other services as well. Payment Service Who doesn\u0026#39;t want to know when payments are coming in? This service generates a payment date that can be used by the invoiceservice or standalone. External tools These labs have an emphasis on using external tools together with Project Flogo, like Kubernetes or the Serverless Framework\nKubernetes Kubernetes is probably the most wellknown container orchestration platform out there. In this demo you explore how to run Flogo apps on Kubernetes. Docker Flogo apps are ultralight, so building docker images is not only really easy, because it can embed all dependencies it can also run inside of super small containers. Cloud Foundry Cloud Foundry is an open-source platform as a service (PaaS) that provides you with a choice of clouds, developer frameworks, and application services (like Flogo!). Serverless Framework Developers never have to worry about provisioning or maintaining servers, and only have to create the code that they need to power their next business idea! PubNub Secure comms with PubNub: Building microservices is cool, having them talk to each other is awesome! But in today\u0026#39;s world, you can\u0026#39;t be too careful when it comes to your data. IoT apps Flogo can run almost anywhere. Take this lab to get yourself familiar with how to develop IoT apps using the Flogo CLI. BeagleBone Deploying apps to a BeagleBone Intel Edison Deploying apps to an Edison Raspberry Pi (IoT) Deploying apps to a Raspberry Pi CI/CD for Activities A CI/CD pipeline is really important for proper a proper test and build cycle. This tutorial walks you through how to do that with Jenkins and Travis for Flogo activities. AWS SAM SAM provides a model to build Serverless apps for AWS. It also provides an easy way of testing your apps without deploying to AWS Lambda all the time... "
},
{
	"uri": "https://tibcosoftware.github.io/configuration/",
	"title": "Configuration",
	"tags": [],
	"description": "",
	"content": "Configuration Configurating your Flogo apps with environment variables and stuff :)\n"
},
{
	"uri": "https://tibcosoftware.github.io/configuration/environment-vars/",
	"title": "Environment variables",
	"tags": [],
	"description": "",
	"content": "List of environment variables to configure the flogo engine\nEnvironment name Default value Info FLOGO_LOG_DTFORMAT \u0026ldquo;2006-01-02 15:04:05.000\u0026rdquo; Sets the log date and time format FLOGO_LOG_LEVEL \u0026ldquo;INFO\u0026rdquo; Sets the log level FLOGO_RUNNER_TYPE \u0026ldquo;POOLED\u0026rdquo; Sets the type of the runner FLOGO_RUNNER_WORKERS 5 Sets the number of workers FLOGO_RUNNER_QUEUE 50 Sets the runner queue size FLOGO_CONFIG_PATH \u0026ldquo;flogo.json\u0026rdquo; Sets the path of the config json file FLOGO_ENGINE_STOP_ON_ERROR true Sets whether to stop the engine on error FLOGO_APP_PROP_RESOLVERS None The property resolver to use at runtime. Refer to the documentation for application properties FLOGO_SCHEMA_SUPPORT FLOGO_SCHEMA_VALIDATION None "
},
{
	"uri": "https://tibcosoftware.github.io/development/",
	"title": "Development",
	"tags": [],
	"description": "",
	"content": "Development All things Flogo when it comes to building your apps\n"
},
{
	"uri": "https://tibcosoftware.github.io/development/apps/",
	"title": "Apps",
	"tags": [],
	"description": "",
	"content": "Apps Do you want to build apps and microservices? Want to better understand the concepts and constructs that make up a app? You\u0026rsquo;ve come to the right place!\n"
},
{
	"uri": "https://tibcosoftware.github.io/development/apps/app-structure/",
	"title": "App structure",
	"tags": [],
	"description": "",
	"content": "Every Flogo app has the same basic structure and files for an application.\nmyApp/\r├── flogo.json\r└── src\r├── go.mod\r├── go.sum\r├── imports.go\r├── main.go files The most important files are\nflogo.json : flogo project application configuration descriptor file imports.go : contains go imports for contributions (activities, triggers, models and functions) used by the application main.go : main file for the engine. directories The most important directories are\nsrc : the place where all code is stored "
},
{
	"uri": "https://tibcosoftware.github.io/development/flows/tensorflow/getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": "First and foremost, Flogo supports inferencing TensorFlow models, it does not support training of models using incoming data. The training should be performed in Python and the SavedModel format exported for inferencing at runtime in Flogo.\nBefore you can begin inferencing TensorFlow models within your Flogo Flows, you’ll need to consider a few requirements.\nPre-requisites The TensorFlow dynamic lib must be installed on both your development machine, as well as the target machine/device. The dynlib must be built specifically for your platform architecture, that is, Linux Arm, x86, x64, Darwin, etc. Follow the instructions documented by TensorFlow, note that the only steps that you\u0026rsquo;ll need to follow are 2 and 3: downloading the correct dynamic lib and setting your lib paths. You do not need to \u0026lsquo;go get\u0026rsquo; TensorFlow.\nTensorFlow Models As previously stated, Flogo is leveraged to inference models at runtime, not train any models. Flogo includes a native activity to inference models. The activity has been developed and tested against the output of the tf.estimator API from TensorFlow as well as manually built models saved with the tf.saved_model module.\n"
},
{
	"uri": "https://tibcosoftware.github.io/development/apps/app-configuration/",
	"title": "App Model",
	"tags": [],
	"description": "",
	"content": "Flogo Application Model The flogo.json file is the metadata describing an application. The application dictates the dependencies to be used during compile time and can also be embeded into the compiled binary.\n{ \u0026#34;name\u0026#34;: \u0026#34;SampleApp\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;flogo:app\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;appModel\u0026#34;: \u0026#34;1.1.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;imports\u0026#34;: [ \u0026#34;github.com/project-flogo/contrib/activity/log\u0026#34;, \u0026#34;github.com/project-flogo/contrib/trigger/rest\u0026#34;, \u0026#34;github.com/project-flogo/flow\u0026#34; ], \u0026#34;triggers\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;receive_http_message\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;#rest\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Receive HTTP Message\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Simple REST Trigger\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;port\u0026#34;: 8080 }, \u0026#34;handlers\u0026#34;: [ { \u0026#34;settings\u0026#34;: { \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/test\u0026#34; }, \u0026#34;action\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;#flow\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;flowURI\u0026#34;: \u0026#34;res://flow:get_name\u0026#34; }, \u0026#34;input\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;=$.content.name\u0026#34; }, \u0026#34;output\u0026#34;: { \u0026#34;code\u0026#34;: 200, \u0026#34;data\u0026#34;: \u0026#34;=$.greeting\u0026#34; } } } ] } ], \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;flow:get_name\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;GetName\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;output\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;greeting\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ] }, \u0026#34;tasks\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;log_2\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Log\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Logs a message\u0026#34;, \u0026#34;activity\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;#log\u0026#34;, \u0026#34;input\u0026#34;: { \u0026#34;message\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;addDetails\u0026#34;: false } } } ] } } ] } Root Properties name: The application name type: The type of application. Currently the only valid value is flogo:app version: Your application version appModel: The version of the current app model. This should be: \u0026ldquo;1.1.0\u0026rdquo; description: Your application description imports: The contributions that your application will use. The imports array is used by the CLI include specific imports and versions in your application at build time. Use this to specify any additional contributions, such as, functions, that you\u0026rsquo;d like to leverage. The CLI will automatically pull any mentioned contribs at app create or during flogo imports sync command. Triggers id: the ID of the trigger settings: global settings for the trigger handlers the handlers for endpoints configured for the trigger actionId: the ID of the action the handler invokes settings: the handler specific settings "
},
{
	"uri": "https://tibcosoftware.github.io/development/flows/tensorflow/inferencing-tf/",
	"title": "Inferencing",
	"tags": [],
	"description": "",
	"content": "Before you begin with the ML Inferencing activity, refer to the Flows \u0026gt; TensorFlow \u0026gt; Getting Started documentation.\nOverview of the Inference Activity The inference activity was built to support the concept of plugable frameworks, however the only supported framework is currently TensorFlow. The activity leverages the Golang API from TensorFlow. You don\u0026rsquo;t need Python or anything other than the TensorFlow dynamic library installed on your dev \u0026amp; target machine.\nInputs model The “model” input to the activity should be either of the following:\nAn archive (zip) of the TensorFlow model A directory containing the exported protobuf and check point files The activity has been tested with the exported model from the tf.estimator.Exporter.export operation as well as manually built models exported with the tf.saved_model module. After export, optionally zip the file, where the saved_model.pb file is located at the root of the archive.\nThe SavedModel format contained in the protobuf includes metadata (interpret this as an instruction manual) on how to use the model. The below inputs and outputs are which parts of the metadata to use to connect to this model.\nfeatures The data to be passed into the SavedModel are defined in “features”. This is an array of maps and should match the following format. For estimators an example of “features” is:\n[ { \u0026#34;name\u0026#34;: \u0026#34;inputs\u0026#34;, \u0026#34;data\u0026#34;:{ \u0026#34;z-axis-q75\u0026#34;: 4.140586, \u0026#34;y-axis-q75\u0026#34;: 4.140586 } } ] And, for manually build models with multiple inputs “features” would be something like:\n[ { \u0026#34;name\u0026#34;: \u0026#34;X1\u0026#34;, \u0026#34;data\u0026#34;:[ [1,2,3], [4,5,6], [7,8,9] ] }, { \u0026#34;name\u0026#34;: \u0026#34;X2\u0026#34;, \u0026#34;data\u0026#34;:[ [0.1,0.2,0.3], [0.4,0.5,0.6], [0.7,0.8,0.9] ] } ] framework The deep learning framework to use for inferencing. Currently the only supported value is: Tensorflow\ntag (default: “serve”) and sigDefName (default: “serving_default”) A TensorFlow model consists of a complex graph (network) of mathematical operations that can contain many moving parts. Another way to consider this is that a model consists of connected “computers” that each have a purpose. To use the model we have to know which computer/part of the model to use. “tag” is used to identify within the model metadata which part of the model to use. Once we have selected the “computer” to use we then need to know which “ports” to use. “sigDefName” is used within the model metadata to properly connect Flogo to the model. These Inputs into the inference activity default to the standard values used by TensorFlow.\nOutputs The output is an object and can contain multiple outputs. For example, for a classification model, the scores and classifications will be held in a map:\nmap[scores:[[0.049997408 0.010411096 0.93959147]] classes:[[Jogging Sitting Upstairs]]] Sample application Refer to the TensorFlow samples\n"
},
{
	"uri": "https://tibcosoftware.github.io/development/apps/application-configuration-provider/",
	"title": "Application Configuration Provider",
	"tags": [],
	"description": "",
	"content": "Unless you want to provide the application configuration (for example: flogo.json) in a different way or format you should not worry about this feature.\nWe have provided an extension mechanism for you to override the default way of providing the application configuration if needed.\nTopics Default behavior Embedded configuration Custom configuration Default behavior Out of the box, the default behavior will be as follows:\nConfiguration will be passed to the engine in the JSON format Default path for the JSON file will be in the same directory as the application\u0026rsquo;s binary Default name for the JSON file will be \u0026ldquo;flogo.json\u0026rdquo; Default path and name can be changed by setting an environment variable \u0026ldquo;flogo.config.path\u0026rdquo; (for example:) # Example changing default configuration path and name $ export flogo.config.path=/path/to/config/myconfig.json Embedded configuration There is an option when building the application to compile the flogo.json and embed it into the code instead of loading it from a file.\n# Example building the application in embedded mode $ flogo build -e Custom configuration If you need to customize the way the configuration is provided to the engine (for example: \u0026ldquo;change the format of the configuration\u0026rdquo;), you just need to do the following:\nPlace a file in the \u0026ldquo;main\u0026rdquo; package of your application that looks like this: package main\rimport (\r\u0026#34;github.com/TIBCOSoftware/flogo-lib/app\u0026#34;\r)\rfunc init () {\r// The name of this variable is IMPORTANT as it is initializing an existing // variable in the main.go\rcp = MyProvider()\r}\r// myProvider implementation of ConfigProvider\rtype myProvider struct {\r}\r//OptimizedProvider returns an app config from a compiled json file\rfunc MyProvider() (app.ConfigProvider){\rreturn \u0026amp;myProvider{}\r}\r// GetApp returns the app configuration\rfunc (d *myProvider) GetApp() (*app.Config, error){\rapp := \u0026amp;app.Config{}\r// Add your own code here\r...\rreturn app, nil\r} "
},
{
	"uri": "https://tibcosoftware.github.io/development/apps/best-practices-app-development/",
	"title": "Best practices for app development",
	"tags": [],
	"description": "",
	"content": "There are a few best practices that we recommend when developing apps and functions using Flogo.\n.gitignore You definitely want to store your apps in a source control system and we recommend the the below template for your .gitignore for Flogo apps\n## Project Flogo .gitignore\r## To restore all dependencies and prepare the project for build run\r## the command `flogo imports sync`\r## bin folder is constructed using flogo build\r/bin using the -cv flag With the flogo cli you\u0026rsquo;re usually on the latest tagged version of the main flogo repos. If you want to pick up the latest master branch, or a specific branch, you can use the -cv flag with flogo create. This flag will pull the specified version of the project-flogo/core when the app structure is built.\nFor flogo-lib you can use github.com/github.com/project-flogo/core@master You can replace master with any branch/tag that you you want\nupdate a package to a specific version By default, the flogo cli will use the latest tagged version of any contrib. If you\u0026rsquo;d like to pick up the latest tagged release, master or a specific tagged release use the flogo update command:\nflogo update github.com/project-flogo/contrib/activity/trigger/rest@master\rflogo update github.com/project-flogo/contrib/activity/trigger/rest@v1.0.0\rflogo update github.com/project-flogo/contrib/activity/trigger/rest@latest "
},
{
	"uri": "https://tibcosoftware.github.io/development/flows/",
	"title": "Flows",
	"tags": [],
	"description": "",
	"content": "Flows Do you want to build flows? Want to better understand the concepts and constructs that make up a flow, such as all the mapping types, valid syntax for mapping, etc? You\u0026rsquo;ve come to the right place!\n"
},
{
	"uri": "https://tibcosoftware.github.io/development/flows/tensorflow/",
	"title": "TensorFlow",
	"tags": [],
	"description": "",
	"content": "TensorFlow Want to leverage TensorFlow within your Flogo Flows? Inference from pre-built estimators and manually constructed models to predict behaviors and outcomes to take action directly within your Flogo Flow.\n"
},
{
	"uri": "https://tibcosoftware.github.io/development/flows/accumulate/",
	"title": "Accumulate Activity Output for All Iterations",
	"tags": [],
	"description": "",
	"content": "What is an Accumulating the Activity Output When using iterate over an activity or Repeat on True, you have the option to specify if you want to cumulative data from all iterations. You can do so by adding accumulate:true to setting, By defaut it set to false\n{ \u0026#34;id\u0026#34;: \u0026#34;rest_3\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;REST Invoke\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Invokes a REST Service\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;condition\u0026#34;: \u0026#34;$activity[RESTInvoke].data.username == \\\u0026#34;Bret\\\u0026#34; \u0026amp;\u0026amp; $iteration[index]\u0026lt;1\u0026#34;, \u0026#34;delay\u0026#34;: 2000, \u0026#34;accumulate\u0026#34;: true }, \u0026#34;type\u0026#34;: \u0026#34;doWhile\u0026#34;, \u0026#34;activity\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;#rest\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;uri\u0026#34;: \u0026#34;https://jsonplaceholder.typicode.com/users/1\u0026#34; } } } When the accumulate set to true, the activity accumulates the data from each iteration and outputs that collective data as an array of objects, where each object contains the output from the corresponding iteration.\nSo the output of the above activity $activity[rest_3] returns\n[ { \u0026#34;status\u0026#34;:200, \u0026#34;header\u0026#34;:{ \u0026#34;Content-Type\u0026#34;:\u0026#34;application/json\u0026#34; }, \u0026#34;data\u0026#34;:{ \u0026#34;id\u0026#34;:1, \u0026#34;name\u0026#34;:\u0026#34;Leanne Graham\u0026#34;, \u0026#34;username\u0026#34;:\u0026#34;Bret\u0026#34;, \u0026#34;email\u0026#34;:\u0026#34;Sincere@april.biz\u0026#34;, \u0026#34;address\u0026#34;:{ \u0026#34;street\u0026#34;:\u0026#34;Kulas Light\u0026#34;, \u0026#34;suite\u0026#34;:\u0026#34;Apt. 556\u0026#34;, \u0026#34;city\u0026#34;:\u0026#34;Gwenborough\u0026#34;, \u0026#34;zipcode\u0026#34;:\u0026#34;92998-3874\u0026#34;, \u0026#34;geo\u0026#34;:{ \u0026#34;lat\u0026#34;:\u0026#34;-37.3159\u0026#34;, \u0026#34;lng\u0026#34;:\u0026#34;81.1496\u0026#34; } }, \u0026#34;phone\u0026#34;:\u0026#34;1-770-736-8031 x56442\u0026#34;, \u0026#34;website\u0026#34;:\u0026#34;hildegard.org\u0026#34;, \u0026#34;company\u0026#34;:{ \u0026#34;name\u0026#34;:\u0026#34;Romaguera-Crona\u0026#34;, \u0026#34;catchPhrase\u0026#34;:\u0026#34;Multi-layered client-server neural-net\u0026#34;, \u0026#34;bs\u0026#34;:\u0026#34;harness real-time e-markets\u0026#34; } } }, { \u0026#34;status\u0026#34;:200, \u0026#34;header\u0026#34;:{ \u0026#34;Content-Type\u0026#34;:\u0026#34;application/json\u0026#34; }, \u0026#34;data\u0026#34;:{ \u0026#34;id\u0026#34;:1, \u0026#34;name\u0026#34;:\u0026#34;Leanne Graham\u0026#34;, \u0026#34;username\u0026#34;:\u0026#34;Bret\u0026#34;, \u0026#34;email\u0026#34;:\u0026#34;Sincere@april.biz\u0026#34;, \u0026#34;address\u0026#34;:{ \u0026#34;street\u0026#34;:\u0026#34;Kulas Light\u0026#34;, \u0026#34;suite\u0026#34;:\u0026#34;Apt. 556\u0026#34;, \u0026#34;city\u0026#34;:\u0026#34;Gwenborough\u0026#34;, \u0026#34;zipcode\u0026#34;:\u0026#34;92998-3874\u0026#34;, \u0026#34;geo\u0026#34;:{ \u0026#34;lat\u0026#34;:\u0026#34;-37.3159\u0026#34;, \u0026#34;lng\u0026#34;:\u0026#34;81.1496\u0026#34; } }, \u0026#34;phone\u0026#34;:\u0026#34;1-770-736-8031 x56442\u0026#34;, \u0026#34;website\u0026#34;:\u0026#34;hildegard.org\u0026#34;, \u0026#34;company\u0026#34;:{ \u0026#34;name\u0026#34;:\u0026#34;Romaguera-Crona\u0026#34;, \u0026#34;catchPhrase\u0026#34;:\u0026#34;Multi-layered client-server neural-net\u0026#34;, \u0026#34;bs\u0026#34;:\u0026#34;harness real-time e-markets\u0026#34; } } } ] "
},
{
	"uri": "https://tibcosoftware.github.io/development/flows/app-events/",
	"title": "App Audit Events",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://tibcosoftware.github.io/development/flows/property-bag/",
	"title": "App Properties",
	"tags": [],
	"description": "",
	"content": "In Flogo, the concept of an application-level property bag is made available to flow developers that want to reuse properties across different flows, within the same application for trigger settings or as input to activities. Properties are exposed via the $property resolver and made available to the scopes defined in the mappings documentation.\nFlow configuration Properties are defined within the root of the application json, as shown below via the properties element.\n{ \u0026#34;name\u0026#34;: \u0026#34;default_app\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;flogo:app\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Sample flogo app\u0026#34;, \u0026#34;properties\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;my_property\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;My Property Value\u0026#34; } ] As previously stated, properties are accessible via the $property resolver. Consider the following mappings into a log activity:\n{ \u0026#34;id\u0026#34;: \u0026#34;log_2\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Log\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Logs a message\u0026#34;, \u0026#34;activity\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;#log\u0026#34;, \u0026#34;input\u0026#34;: { \u0026#34;addDetails\u0026#34;: false, \u0026#34;message\u0026#34;: \u0026#34;=$property[my_property]\u0026#34; } } } Grouping of properties You can create an artifical grouping of related properties by using .\u0026hellip;.. naming convention. Note that property keys are still simply string literals, the engine does not do any grouping.\n{ \u0026#34;name\u0026#34;: \u0026#34;default_app\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;flogo:app\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Sample flogo app\u0026#34;, \u0026#34;properties\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;PURCHASE.SERVICE.DB.URL\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;postgres://10.10.10.10:5370/mydb\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;PURCHASE.SERVICE.DB.USER\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;testuser\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;INVENTORY.SERVICE.DB.URL\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;postgres://10.10.10.20:5370/mydb\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;INVENTORY.SERVICE.DB.USER\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;testuser\u0026#34; } ] These properties can be accessed via $property[PURCHASE.SERVICE.DB.URL] or $property[INVENTORY.SERVICE.DB.URL]\nOverriding app properties at runtime You can override app properties at runtime in two ways:\nUsing JSON Define your new value for a given app prop in a json file as shown below:\nprops.json { \u0026ldquo;MyProp1\u0026rdquo;: \u0026ldquo;This is new value\u0026rdquo;, \u0026ldquo;MyProp2\u0026rdquo;: 20 }\nRun app with the environment variable FLOGO_APP_PROPS_OVERRIDE set to props.json. For example:\nFLOGO_APP_PROPS_OVERRIDE=props.json ./MyApp Using Key/Value pair Run app with the environment variable FLOGO_APP_PROPS_OVERRIDE set to the key/value pairs. For example:\nFLOGO_APP_PROPS_OVERRIDE=\u0026#34;MyProp1=This is newvalue,MyProp2=30\u0026#34; ./MyApp Working with external configuration management services You can plug-in your own value resolver to resolve application property value from external configuration management services, such as, Consul, Spring Cloud Config etc. Just implement the following interface and register implementation with the runtime:\n// PropertyValueResolver used to resolve value from external configuration like env, file etc type PropertyValueResolver interface { // Should return value and true if the given application property exists in the external configuration otherwise should return nil and false. LookupValue(propertyName string) (interface{}, bool) } Sample Resolver package sampleresolver type SamplePropertyResolver struct { } func init() { app.RegisterPropertyValueResolver(\u0026#34;sampleresolver\u0026#34;, \u0026amp;SamplePropertyResolver{}) } func (resolver *SamplePropertyResolver) LookupValue(propertyName string) (interface{}, bool) { // Resolve property value return some_value, true } Set the FLOGO_APP_PROPS_RESOLVERS env var to sampleresolver while running application. For example:\nFLOGO_APP_PROPS_RESOLVERS=sampleresolver ./\u0026lt;app_binary\u0026gt; "
},
{
	"uri": "https://tibcosoftware.github.io/development/flows/io-parameters/",
	"title": "Flow Input/Output Params",
	"tags": [],
	"description": "",
	"content": "For Flogo a Flow is more inline with the concept of a function, that is, a Flow has both input and output parameters. The concept of decoupling a trigger from a flow is a key part of supporting multiple triggers and re-use/sharing of a flow. A Flow can now operate against the data that it has defined within its declartion, in otherwords, just like a function, the scope of data that a Flow can operate against must reside within either the Flow context (or as an environment variable).\nSetting Flow Input and Output Params When building a Flow, you must first define the input and output params, that is, what are the input parameters that a flow can operate against and what parameters will be returned once the Flow has finished executing. To do this, we have options, either use the WebUI or construct the JSON manually.\nFrom the WebUI, open your new Flow, and click the \u0026ldquo;Flow Params\u0026rdquo; box, you\u0026rsquo;ll be presented with the Flow input/output editor.\nYou will be presented with a dialog containing two tabs, Input and Output. Use this dialog to define your input and output parameters.\nIf you intend to perform complex object mapping choose the type \u0026lsquo;object\u0026rsquo; for either an input or output param. This enables you to construct your own JSON, refer to the Flow Mappings section for details.\nIf you\u0026rsquo;d prefer to define the Flows input and output params via the application JSON, you may do so\n{ \u0026#34;id\u0026#34;: \u0026#34;flow:my_function\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;MyFunction\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;output\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;greeting\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;any\u0026#34; } ] } } } Mapping Trigger Output and Reply Because a Flow operates against its own locally scoped data (params), you will need to map the trigger data into the Flow params, as well as the flow params to the triggers reply params(s). This may sound a bit odd at first, however is required to ensure that a trigger is entierly decoupled from a flow, as previously said, enabling flows to be re-used and support multiple paths of invocation via different triggers.\nBefore we jump in, to understand the concepts used here:\nTrigger output: A trigger is an event-driven construct used to invoke a Flow. A trigger will run logic and perpare data that must be used within a Flow. Think of a REST trigger, the output of the trigger to the Flow will be things like the request data, the HTTP headers, etc. Trigger reply: After a Flow has finished executing, it may be desierable to send back data in response to the triggers request. Consider a REST trigger. If the verb was a GET, the reply would be the payload that the trigger must return to the caller. To map the trigger data using the WebUI, add a trigger to your Flow, and click on it.\nNow select \u0026ldquo;Map flow params\u0026rdquo;.\nNow you can map the output of the trigger to Flow input params, and Flow output params can be mapped to the reply params available for the trigger.\nIf you choose to map directly within the JSON, consider the following triggers definition\n\u0026#34;triggers\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;aws_lambda_trigger\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;#lambda\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;AWS Lambda Trigger\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;AWS Lambda Trigger\u0026#34;, \u0026#34;handlers\u0026#34;: [ { \u0026#34;action\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;#flow\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;flowURI\u0026#34;: \u0026#34;res://flow:my_function\u0026#34; }, \u0026#34;input\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;=$.event.name\u0026#34; }, \u0026#34;output\u0026#34;: { \u0026#34;data\u0026#34;: \u0026#34;=$.greeting\u0026#34;, \u0026#34;status\u0026#34;: 200 } } } ] } ] Note the input and output objects within the handler definition.\n"
},
{
	"uri": "https://tibcosoftware.github.io/development/flows/iterators/",
	"title": "Iterator",
	"tags": [],
	"description": "",
	"content": "What is an iterator in Flogo? The iterator construct in Flogo enables the iteration of a single activity. The configuration elements are associated with that activity. In Flogo, you can iterate only over a single activity. The iterator acts much like a foreach loop in any procedural language. If you need to iterate over multiple activity calls, simply place an iterator on a subflow.\nFlow configuration Iterators are associated with an activity. The activity must have the type declared and set to iterator, as well as the iterate setting defined and the value would be either the array to iterate over or a scalar value.\n{ \u0026#34;id\u0026#34;: \u0026#34;log_2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;iterator\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Log\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Logs a message\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;iterate\u0026#34;: 1 }, \u0026#34;activity\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;#log\u0026#34;, \u0026#34;input\u0026#34;: { \u0026#34;addDetails\u0026#34;: false, \u0026#34;message\u0026#34;: \u0026#34;=string.concat(\\\u0026#34;Hello \\\u0026#34;, $flow.name)\u0026#34; } } } A few important things to note:\nA new settings element with a property named iterate set to the array that should be iterated over. It is also possible to define a static value, for example, if the value of \u0026ldquo;10\u0026rdquo; was specified, the iterator construct would invoke this activity 10 times The $iterate scope has now been introduced and can be used to access the value and key of the current iteration. The $iterate scope has two properties:\n$current[value]: The value of the current iteration, that is, the object of the current array $current[key]: The current key (1, 2, etc) "
},
{
	"uri": "https://tibcosoftware.github.io/development/flows/mapping/",
	"title": "Mappings",
	"tags": [],
	"description": "",
	"content": "What are mappings? A mapping in Flogo can be used to assign the value of a parameter (flow input, for example) to that of an input parameters of an activity or to the value of another flow scoped variable.\nTypes of mappings Flogo infers the mapping type based on the structure of the mapping itself. The following list details the specifics around each mapping type.\nType Description Format literal A literal mapping. For example, mapping the string \u0026ldquo;hello\u0026rdquo; to a string typed input. Simply enclose your string literal in double quotes: \u0026quot; \u0026quot; expression Expression mapping. This enable using functions and expression condition in mamping The mapping string should begin with an equals character = object Complex object. Used when a JSON-based object must be built and values assigned from other scoped properties/activity outputs. See details below. array Array mapping. Mapping an Array of Objects. See details below Mappings are quite straightforward, for example:\n{ \u0026#34;isbn\u0026#34;: \u0026#34;=$.event.isbn\u0026#34; } The above mapping indicates that the value of event.isbn from a trigger input should be mapped to the action input named isbn. Consider two additional samples, below you will find a mapping to an activity from a $flow scoped property, a literal mapping, as well as an object type object mapping.\nType expression from a flow-scoped property\n{ \u0026#34;isbn\u0026#34;: \u0026#34;=$flow.isbn\u0026#34; } Type literal:\n{ \u0026#34;isbn\u0026#34;: \u0026#34;12937\u0026#34; } Type object:\n{ \u0026#34;bookDetails\u0026#34;: { \u0026#34;mapping\u0026#34;: { \u0026#34;Author\u0026#34;: \u0026#34;=$flow.author\u0026#34;, \u0026#34;ISBN\u0026#34;: \u0026#34;=$flow.name\u0026#34;, \u0026#34;Price\u0026#34;: \u0026#34;$20\u0026#34; } } } The literal mappings are pretty simple to understand, as are the flow scoped expression mappings. However type object does require a bit of an explanation. The mapping object is used to define how the object should be constructed and the various fields within the object mapped. This is done for performance reasons to avoid any unnecessary parsing of property values.\nIf you assign the value of an array then that param will be treated as an array, likewise for a string, int, etc. For example, let us pretend $flow.Author is an array, then the Author object would also be an array. In otherwords, direct assignment is occurring.\nThe WebUI insulates you frome much of this understanding and will infer the correct mapping type.\nAdditional type expression:\n{ \u0026#34;data.description\u0026#34;: \u0026#34;=string.concat(\\\u0026#34;The pet category name is: \\\u0026#34;, $activity[rest_3].result.category.name)\u0026#34;, } The above sample leverages the output of a REST Invoke activity to get a pet from the public petstore service. The mapper uses a string concat function string.concat(str1, str2, str3) and assigns the function return to the description field.\nType array:\nExample 1: iterator array $fow.store.books and assign value to books\n{ \u0026#34;books\u0026#34;: { \u0026#34;mapping\u0026#34;: { \u0026#34;@foreach($flow.store.books)\u0026#34;: { \u0026#34;author\u0026#34;: \u0026#34;=$loop.author\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;=$loop.title\u0026#34;, \u0026#34;price\u0026#34;: \u0026#34;=$loop.price\u0026#34; } } } } The above example showing how array mapping works. the mapping node same with object mapper which is used to identity an object mapping. The example: Iterate $flow.store.books source array\u0026rsquo;s author, title and price to target array books, The final target books:\n{ \u0026#34;books\u0026#34;: [ { \u0026#34;author\u0026#34;:\u0026#34;xxxx\u0026#34;, \u0026#34;titile\u0026#34;:\u0026#34;xxxx\u0026#34;, \u0026#34;price\u0026#34;: 33.33 } ] } Description of the mapping.\nMapping Resolvers Flogo will resolve mappings with the following reference. Note the scopes table below, which indicates what objects are accessible within what scope.\nScope Description $env Used to resolve an environment variable $property Used to resolve properties from the global application property bag $flow Used to resolve params from within the current flow. If a flow has a single trigger and no input params defined, then the output of the trigger is made available via $flow $activity Used to resolve activity params. Activities are referenced by id, for example, $activity[acivity_id].activity_property. $iteration[key] \u0026amp;\u0026amp; $iteration[value] Used to resolve data scoped to a current iterator Mapping Scopes Flogo has the concept of mapping resolvers and resolvers are contained within a specific scope, hence not all objects can be accessed from anywhere within the scope.\nMapper Scope Trigger-\u0026gt;Settings env and property resolvers Trigger-\u0026gt;Handler-\u0026gt;Settings env and property resolvers Trigger-\u0026gt;Handler-\u0026gt;actionMapper/input Trigger ouput \u0026lt;\u0026ndash; \u0026ldquo;value\u0026rdquo; field - only property and env resolver can be used. That is, only the output of the trigger or an environment variable can be used here. Trigger-\u0026gt;Handler-\u0026gt;actionMapper/output action scope. Properties defined as ahe output of the flow can be used. Action-\u0026gt;Flow-\u0026gt;Activity-\u0026gt;inputMapper/input flow \u0026lt;\u0026ndash; \u0026ldquo;value\u0026rdquo; field - all resolvers can be used Action-\u0026gt;Flow-\u0026gt;Activity-\u0026gt;inputMapper/output activity input Action-\u0026gt;Flow-\u0026gt;Activity-\u0026gt;outputMapper/input activity output Action-\u0026gt;Flow-\u0026gt;Activity-\u0026gt;outputMapper/output flow Link Expression all resolvers can be used for link expressions. Mapping Syntax Flogo leverages a few simple syntax paradigms when mapping. The first being, the $ character which is used when accessing/reading a property and the pre-fixed . indicates that the value is available within the current scope. For example, consider the following mapping:\n{ \u0026#34;isbn\u0026#34;: \u0026#34;=$.event.isbn\u0026#34; } The above mapping is from the Trigger/Handler, which we know, based on the indication of the ., we can only access trigger scoped (output) variables, thus event.isbn is within the trigger scope, as indicated by the preceding ..\nWhat if you\u0026rsquo;re accessing a property out of the immediate scope? The mapping should be prefixed with the $ special character, indicating to the resolver that we\u0026rsquo;re accessing a property out of the immediate scope. For example, consider the following.\n\u0026#34;input\u0026#34;: { \u0026#34;message\u0026#34;: \u0026#34;=string.concat(\\\u0026#34;Hello \\\u0026#34;, $flow.name)\u0026#34; } This mapping is associated with Action-\u0026gt;Flow-\u0026gt;Activity-\u0026gt;inputMapper. We know that all resolvers can be used within the context, however none of the variables would be within the immediate scope, hence the $ should be used. For example, in the above snippet, we\u0026rsquo;re grabbing the value of the flow variable named name, hence $flow.name is used. If we wanted to grab the value of an environment variable we could use $env.VarName.\nAccessing object properties Most of the time you wont want to perform a direct assigning from one complex object to another, rather you\u0026rsquo;ll want to grab a simple type property from one complex object and perform a direct assigning to another property. This can be done accessing children using a simple dot notation. For example, consider the following mapping.\n{ \u0026#34;someObject\u0026#34;: { \u0026#34;mapping\u0026#34;: { \u0026#34;Title\u0026#34;: \u0026#34;=$activity[rest_3].result.items[0].volumeInfo.title\u0026#34;, \u0026#34;PublishedDate\u0026#34;: \u0026#34;=$activity[rest_3].result.items[0].volumeInfo.publishedDate\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;=$activity[rest_3].result.items[0].volumeInfo.description\u0026#34; } } } someObject is a type object and has the properties Titie, PublishedDate, Description which are being mapped from the response of an activity, this is fetched using the $activity scope. Consider one of the examples:\n$activity[rest_3].result.items[0].volumeInfo.title\nWe\u0026rsquo;re referencing the result property from the activity named rest_3. We\u0026rsquo;re then accessing an items array (the first entry of the array) to another complex object, where finally we\u0026rsquo;re at a simple string property named title.\nUsing functions and expression Most of time you want to add some custome logic to the mapping, such as concat/substring/length of a string or generate a random number base on a range and so on. any logic you want to add you can come up with an function. Refer to the functions repository for all available functions. Also note, you can install custom functions using the CLI\u0026rsquo;s flogo install command.\n{ \u0026#34;description\u0026#34;: \u0026#34;=string.concat(\\\u0026#34;The pet category name is: \\\u0026#34;, $activity[rest_3].result.category.name)\u0026#34; } The function or expression condition can also use to link expreesion in branch, any functions that return a boolean can use in link expression.\n{ \u0026#34;from\u0026#34;: \u0026#34;log_2\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;log_4\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;expression\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$activity[rest_3].result.category.name == \\\u0026#34;BOOK\\\u0026#34;\u0026#34; } or { \u0026#34;from\u0026#34;: \u0026#34;log_2\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;log_4\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;expression\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;string.len($flow.name) \u0026gt; 0\u0026#34; } Hanlding arrays in mappings There are lots of use cases for array mapping, map entire array to another or iterator partial array to another with functions The array mapping value comes from a JSON format\nCase 1: iterator array $fow.store.books and assign value to books\n{ \u0026#34;books\u0026#34;: { \u0026#34;mapping\u0026#34;: { \u0026#34;@foreach($flow.store.books)\u0026#34;: { \u0026#34;author\u0026#34;: \u0026#34;=$loop.author\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;=$loop.title\u0026#34;, \u0026#34;price\u0026#34;: \u0026#34;=$loop.price\u0026#34; } } } } Case 2: Copy original array $fow.store.books to target array books\n{ \u0026#34;books\u0026#34;: { \u0026#34;mapping\u0026#34;: { \u0026#34;@foreach($flow.store.books)\u0026#34;: { \u0026#34;=\u0026#34;: \u0026#34;$loop\u0026#34; } } } } Case 3: Iterator array $fow.store.books and assign to primitive array titles\n{ \u0026#34;titles\u0026#34;: { \u0026#34;mapping\u0026#34;: { \u0026#34;@foreach($flow.store.books)\u0026#34;: { \u0026#34;=\u0026#34;: \u0026#34;$loop.title\u0026#34; } } } } Case 4: Accessing parent loop data.\n{ \u0026#34;books\u0026#34;: { \u0026#34;mapping\u0026#34;: { \u0026#34;@foreach($flow.store.books, bookLoop)\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;=$loop.title\u0026#34;, \u0026#34;price\u0026#34;: \u0026#34;=$loop.price\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@foreach($loop.author, authorLoop)\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;=$loop.firstName\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;=$loop[authorLoop].lastName\u0026#34;, \u0026#34;bookTitle\u0026#34;: \u0026#34;=$loop[bookLoop].title\u0026#34; } } } } } } Case 5: Using fixed array, same as object mapper\n{ \u0026#34;store\u0026#34;: { \u0026#34;mapping\u0026#34;: { \u0026#34;store\u0026#34;: { \u0026#34;books\u0026#34;: [ { \u0026#34;author\u0026#34;: \u0026#34;=string.concat($activity[rest].result.firstName, $activity[rest].result.lastName)\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Five little ducks\u0026#34;, \u0026#34;price\u0026#34;: 19.99 }, { \u0026#34;author\u0026#34;: \u0026#34;=string.concat($activity[rest2].result.firstName, $activity[rest2].result.lastName)\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;I love trucks\u0026#34;, \u0026#34;price\u0026#34;: 11.99 } ] } } } } Addding @foreach(source, loopName\u0026lt;optional\u0026gt;) to indicate doing array mapping on source data Using $loop.xxx to access the current loop data xxx is the object field name Using $loop[loopName].xxx to access specific loop data Note You can use any literal, functions, expression in array mapping.\n{ \u0026#34;books\u0026#34;: { \u0026#34;mapping\u0026#34;: { \u0026#34;@foreach($flow.store.books)\u0026#34;: { \u0026#34;author\u0026#34;: \u0026#34;=string.concat($activity[rest].result.firstName, $activity[rest].result.lastName)\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Five little ducks\u0026#34;, \u0026#34;price\u0026#34;: 19.99 } } } } "
},
{
	"uri": "https://tibcosoftware.github.io/development/flows/dowhile/",
	"title": "Repeat on True(dowhile)",
	"tags": [],
	"description": "",
	"content": "What is an Repeat on True(doWhile) in Flogo? The current iterator feature allows a user to repeat an activity on a fixed number of times by configuring the iterate property. However, there are are certain scenarios where a user would like to repeat an activity based on the output of the current activity or previous activties. To support this, a new feature Repeat on true has been included as part of release 0.9.4.\nFlow configuration Repeat on True(dowhile) are associated with an activity. The activity must have the type declared and set to doWhile.\nTo begin with, the Repeat on true feature has two attributes under setting\ncondition: A boolean expression that can be built using the current activity\u0026rsquo;s output and previous activity\u0026rsquo;s outputs. delay: The time in milliseconds to wait before executing the next iteration, by default, the delay is 0 implying there will be no delay between each iteration. Along with the current and previous activities\u0026rsquo; output, the value for condition can use a special attribute $iteration[index] to track the index of the iteration. This is often useful if the user does not want the activity to repeat indefinitely.\n{ \u0026#34;id\u0026#34;: \u0026#34;rest_3\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;REST Invoke\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Invokes a REST Service\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;condition\u0026#34;: \u0026#34;$activity[RESTInvoke].data.username == \\\u0026#34;Bret\\\u0026#34; \u0026amp;\u0026amp; $iteration[index]\u0026lt;=3\u0026#34;, \u0026#34;delay\u0026#34;: 2000 }, \u0026#34;type\u0026#34;: \u0026#34;doWhile\u0026#34;, \u0026#34;activity\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;#rest\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;uri\u0026#34;: \u0026#34;https://jsonplaceholder.typicode.com/users/1\u0026#34; } } } Important note: The condition evalucate after activity execution and $iteration[index] start with 0, which also means first execution must been made to determin next or not base on condition. The activity will always been execute $iteration[index] + 1 times\nSince the activity is of type \u0026quot;doWhile\u0026quot;, the condition attribute is evaluated to determine if/not the activity must be repeated. For the above activity, since the first part of the condition is always true for that url, the second part i.e $iteration[index]\u0026lt;=3 will determine if the activity needs to be repeated or not.\n"
},
{
	"uri": "https://tibcosoftware.github.io/development/flows/retryonerror/",
	"title": "Retry On Error",
	"tags": [],
	"description": "",
	"content": "What is an Retry On Error in Flogo? There are certain scenarios where a user would like to retry an activity when an error is encountered. To support this, a new feature Retry On Error has been included as part of release 0.9.4.\nFor this feature to function two areas need to be have configured:\nFlow configuration Runtime Code Flow configuration For an activity to be configured with Retry on error, a new node \u0026quot;retryOnError\u0026quot; must be added to the settings of the activity. There are two configuration attributes available on the \u0026quot;retryOnError\u0026quot; node:\ncount:(int) The maximum number of times the activity can be retried in case of an error. interval: (int) The time in milliseconds between each retry attempt. By default, the value for interval is 0, which implies each retry attempt will be executed immediately. For example, a sample rest activity configured with retryOnError will look as below:\n{ \u0026#34;id\u0026#34;: \u0026#34;rest_3\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;REST Invoke\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Invokes a REST Service\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;retryOnError\u0026#34;: { \u0026#34;count\u0026#34;: 3, \u0026#34;interval\u0026#34;: 2000 } }, \u0026#34;activity\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;#rest\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;uri\u0026#34;: \u0026#34;https://jsceholder.typicode.com/users/1\u0026#34; } } } The above activity will be retried for a maximum of three consecutive times when an error occurs. The activity will sleep for an interval of 2000ms between each retry attempt.\nRuntime code To make all functional the runtime code must return false with retriable error at eval method, engine will retry only on retriable error.\nsuch as:\nresp, err := client.Do(req) if err != nil { if err2, ok := err.(*url.Error); ok { // Return retriable error return false, activity.NewRetriableError(err2.Error(), \u0026#34;\u0026#34;, nil) } log.Errorf(\u0026#34;Failed to send request due to error: %s\u0026#34;, err.Error()) return false, err } "
},
{
	"uri": "https://tibcosoftware.github.io/development/webui/",
	"title": "Web UI",
	"tags": [],
	"description": "",
	"content": "Web UI Building flows using the Web UI is awesome! Check out this section to see all the out of the box activities we have!\n"
},
{
	"uri": "https://tibcosoftware.github.io/development/webui/activities/",
	"title": "Activities",
	"tags": [],
	"description": "",
	"content": "Activities An activity is the unit of work that can be leveraged within a Flow. Here is the list of the out of the box activities. If it isn\u0026rsquo;t here, check the showcase to see the amazing contributions of our community\n"
},
{
	"uri": "https://tibcosoftware.github.io/development/webui/functions/",
	"title": "Functionss",
	"tags": [],
	"description": "",
	"content": "Functions Flogo Functions can be used within mapping expressions to enable a more powerful experience. For example, when mappingh data, coerce it to a specific time, concat two strings, etc.\n"
},
{
	"uri": "https://tibcosoftware.github.io/development/webui/triggers/",
	"title": "Triggers",
	"tags": [],
	"description": "",
	"content": "Triggers Flogo is an event-driven framework. A trigger is the entrypoint for events. A trigger can be a subscriber on an MQTT topic, Kafka topic, HTTP REST interface or a specific IoT sensor. . Here is the list of the out of the box activities. If it isn\u0026rsquo;t here, check the showcase to see the amazing contributions of our community\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo-cli/",
	"title": "Flogo CLI Tools",
	"tags": [],
	"description": "",
	"content": "Flogo CLI Discover the Flogo CLI tools to build applications \u0026amp; extensions.\n"
},
{
	"uri": "https://tibcosoftware.github.io/deployments/",
	"title": "Cloud Deployments",
	"tags": [],
	"description": "",
	"content": "Deploy to all the clouds Flogo can be deployed to pretty much any cloud platform that exists today, whether it is a FaaS platform or a more traditional cloud platform.\nKubernetes is probably the most wellknown container orchestration platform out there. In this demo you explore how to run Flogo apps on Kubernetes. The demo will walk you thro Flogo apps are ultralight, so building docker images is not only really easy, because it can embed all dependencies it can also run inside of super small containers. Check out Cloud Foundry is an open-source platform as a service (PaaS) that provides you with a choice of clouds, developer frameworks, and application services. The most awesome thing? After you\u0026rsquo;re done with these samples, why not check out the other labs we have for you!\n"
},
{
	"uri": "https://tibcosoftware.github.io/iot/",
	"title": "IoT",
	"tags": [],
	"description": "",
	"content": "The Internet of Things The Internet of Things is a magnificent place and with Flogo you can make it even better. To get started we\u0026rsquo;ve created a write-up of how to deploy your Flogo apps to some of the most common devices we could find.\nFlogo can run almost anywhere. From the largest clouds, to the smallest of devices and everything in between. Take this lab to get yourself familiar with how to develop apps f Deploying apps to a BeagleBone Deploying apps to an Edison Deploying apps to a Raspberry Pi After you\u0026rsquo;re done with these samples, why not check out the other labs we have for you!\n"
},
{
	"uri": "https://tibcosoftware.github.io/faas/",
	"title": "FaaS",
	"tags": [],
	"description": "",
	"content": "Flows as Functions for Serverless Platforms Discover how you can use Project Flogo to build a Flow as Functions.\n"
},
{
	"uri": "https://tibcosoftware.github.io/faas/how-to/",
	"title": "Flogo and Lambda",
	"tags": [],
	"description": "",
	"content": " Serverless is all around us and perhaps the fastest growing market for compute. Flogo has first class support for AWS Lambda. So you can infinitely scale your ultralight functions and scale back to zero when not in use with AWS Lambda’s NoOps and seamless scaling capabilities.\nWe’ll guide you through the set of steps required to build the most basic of functions for deployment to AWS Lambda. The flow you’ll build will be the function you deploy.\nPrerequisites Before we get started there are a few prerequisites that we need to take into account:\nYou’ll need to have the Flogo CLI and at least Go 1.11 installed If you want to deploy using the AWS cli you\u0026rsquo;ll need to install that too You’ll obviously need an AWS account :) Create the flogo.json Flogo apps are constructed using a JSON file called flogo.json. You can create those files using the Flogo Web UI, or you can create them manually. You can copy the below content and paste it into a file called flogo.json. The Flogo app has a Lambda trigger which can be triggered by any event supported by AWS Lambda.\n{ \u0026#34;name\u0026#34;: \u0026#34;myApp\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;flogo:app\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;appModel\u0026#34;: \u0026#34;1.1.0\u0026#34;, \u0026#34;imports\u0026#34;: [ \u0026#34;github.com/project-flogo/flow\u0026#34;, \u0026#34;github.com/project-flogo/aws-contrib/trigger/lambda\u0026#34;, \u0026#34;github.com/project-flogo/contrib/activity/actreturn\u0026#34;, \u0026#34;github.com/project-flogo/contrib/activity/log\u0026#34;, \u0026#34;github.com/project-flogo/contrib/function/string\u0026#34; ], \u0026#34;triggers\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;aws_lambda_trigger\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;#lambda\u0026#34;, \u0026#34;settings\u0026#34;: null, \u0026#34;handlers\u0026#34;: [ { \u0026#34;settings\u0026#34;: null, \u0026#34;actions\u0026#34;: [ { \u0026#34;ref\u0026#34;: \u0026#34;#flow\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;flowURI\u0026#34;: \u0026#34;res://flow:my_function\u0026#34; }, \u0026#34;input\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;=$.event.name\u0026#34; }, \u0026#34;output\u0026#34;: { \u0026#34;data\u0026#34;: \u0026#34;=$.greeting\u0026#34;, \u0026#34;status\u0026#34;: 200 } } ] } ] } ], \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;flow:my_function\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;MyFunction\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;output\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;greeting\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;any\u0026#34; } ] }, \u0026#34;tasks\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;log_2\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Log\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Logs a message\u0026#34;, \u0026#34;activity\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;#log\u0026#34;, \u0026#34;input\u0026#34;: { \u0026#34;addDetails\u0026#34;: false, \u0026#34;message\u0026#34;: \u0026#34;=string.concat(\\\u0026#34;Hello \\\u0026#34;, $flow.name)\u0026#34; } } }, { \u0026#34;id\u0026#34;: \u0026#34;actreturn_3\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Return\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Return Activity\u0026#34;, \u0026#34;activity\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;#actreturn\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;mappings\u0026#34;: { \u0026#34;greeting\u0026#34;: { \u0026#34;mapping\u0026#34;: { \u0026#34;Hello\u0026#34;: \u0026#34;=$flow.name\u0026#34; } } } } } } ], \u0026#34;links\u0026#34;: [ { \u0026#34;from\u0026#34;: \u0026#34;log_2\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;actreturn_3\u0026#34; } ] } } ] } Create an app To create the source code simply execute\nflogo create -f flogo.json myapp This tells the flogo cli to take the flogo.json file and create the source for the app in a folder called myapp. It will also download a few Go packages that the app will need.\nBuild The next step is to build the executable and for that we need to be in the directory myapp. To build a flogo app from the source that you can run on AWS Lambda we\u0026rsquo;ll need to execute the command\nflogo build -e --shim aws_lambda_trigger . This command tells the flogo cli to build the app as an embedded application (the -e option) and with a target shim (the \u0026ndash;shim option which uses the trigger id). The AWS Lambda trigger leverages a makefile to kick off the build process, which simply builds your Flogo application using the Lambda trigger shim and zips the binary for deployment to AWS Lambda.\nOnce this command finishes successfully the zip file (handler.zip) will be located in your app src directory (for example /path/to/app/lambda/src/lambda/handler.zip).\nDeploy There are several ways to deploy to AWS Lambda. A non-exhaustive list is:\nUploading the code Using SAM templates Using Serverless Framework Using the AWS CLI In this scenario we\u0026rsquo;ll look at numbers 1 and 4\nUploading the code From the Lambda console you can easily create a new function. As you do that set the runtime to Go 1.x, upload the zip file and set the handler to handler.\nUsing the AWS CLI To deploy your app using the AWS CLI go to the directory where the zip was created and from there execute the command\naws lambda create-function --function-name tutorial --runtime go1.x --role arn:aws:iam::\u0026lt;account\u0026gt;:role/\u0026lt;role name\u0026gt; --handler handler --zip-file \u0026#34;fileb://handler.zip\u0026#34; This will create a new function in Lambda called tutorial, which uses the Go runtime. The \u0026ndash;role arn:aws:iam:::role/ is the full ARN of the IAM role used to deploy this function. If all went well you\u0026rsquo;ll see a JSON response like this:\n{ \u0026#34;TracingConfig\u0026#34;: { \u0026#34;Mode\u0026#34;: \u0026#34;PassThrough\u0026#34; }, \u0026#34;CodeSha256\u0026#34;: \u0026#34;KzHoXLnTXi9uMugXAOLrMHq6qJ6RimzYdNfrWXIxwLw=\u0026#34;, \u0026#34;FunctionName\u0026#34;: \u0026#34;tutorial\u0026#34;, \u0026#34;CodeSize\u0026#34;: 4026592, \u0026#34;RevisionId\u0026#34;: \u0026#34;94b184e5-74e3-4881-abf5-debad47541b5\u0026#34;, \u0026#34;MemorySize\u0026#34;: 128, \u0026#34;FunctionArn\u0026#34;: \u0026#34;arn:aws:lambda:\u0026lt;region\u0026gt;:\u0026lt;account\u0026gt;:function:tutorial\u0026#34;, \u0026#34;Version\u0026#34;: \u0026#34;$LATEST\u0026#34;, \u0026#34;Role\u0026#34;: \u0026#34;arn:aws:iam::\u0026lt;account\u0026gt;:role/\u0026lt;role\u0026gt;\u0026#34;, \u0026#34;Timeout\u0026#34;: 3, \u0026#34;LastModified\u0026#34;: \u0026#34;2018-05-12T19:30:41.116+0000\u0026#34;, \u0026#34;Handler\u0026#34;: \u0026#34;handler\u0026#34;, \u0026#34;Runtime\u0026#34;: \u0026#34;go1.x\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;\u0026#34; } Testing 1\u0026hellip; 2\u0026hellip; 3\u0026hellip; The only thing left is to test your function. To do that log into AWS and select \u0026ldquo;Lambda\u0026rdquo;, you\u0026rsquo;ll be presented with all the functions you\u0026rsquo;ve deployed so far and one of them will be called tutorial. Click on that, and you\u0026rsquo;ll see the overview of your function, including a large button that says \u0026ldquo;Test\u0026rdquo;. Click \u0026ldquo;Test\u0026rdquo; to configure a new test event. The input for the test event should be\n{\r\u0026#34;name\u0026#34;: \u0026#34;World\u0026#34;\r} You can replace \u0026ldquo;world\u0026rdquo; with any name or message you want\nFrom there, click \u0026ldquo;Test\u0026rdquo; and the execution logs will display the result\n{\r\u0026#34;Hello\u0026#34;: \u0026#34;World\u0026#34;\r} And the log output\nSTART RequestId: 2f4086f8-5721-4bf4-b0b7-94cb9d52c709 Version: $LATEST\r2019/05/13 13:13:37 Received request: 2f4086f8-5721-4bf4-b0b7-94cb9d52c709\r2019/05/13 13:13:37 Payload Type: unknown\r2019/05/13 13:13:37 Payload: \u0026#39;map[name:Matt]\u0026#39;\rEND RequestId: 2f4086f8-5721-4bf4-b0b7-94cb9d52c709\rREPORT RequestId: 2f4086f8-5721-4bf4-b0b7-94cb9d52c709\tDuration: 0.76 ms\tBilled Duration: 100 ms Memory Size: 512 MB\tMax Memory Used: 30 MB As you\u0026rsquo;re glancing over the results, also look at the Duration and Max Memory Used. Isn\u0026rsquo;t that one of the smallest functions you\u0026rsquo;ve seen?!\n"
},
{
	"uri": "https://tibcosoftware.github.io/contributing/",
	"title": "Contribute",
	"tags": [],
	"description": "",
	"content": "Contribute Discover how you can contribute to Project Flogo!\n"
},
{
	"uri": "https://tibcosoftware.github.io/contributing/contribute-to-docs/",
	"title": "Building the docs website",
	"tags": [],
	"description": "",
	"content": "If you want to contribute to the documentation, that is awesome! Your help is very much appreciated, but please do keep in mind the instructions below.\nPrerequisites These documentation pages are built with Hugo and we do make some assumptions:\nYou have Git 2.5 or greater installed on your machine. You have a GitHub account. Signing up for GitHub is free. You have Hugo installed on your machine. In Hugo, pages are the core of your site. Once it is configured, pages are definitely the added value to your documentation site.\nFolders Organize your site like any other Hugo project. Typically, you will have a content folder with all your pages.\ncontent\r├── level-one │ ├── level-two\r│ │ ├── level-three\r│ │ │ ├── level-four\r│ │ │ │ ├── _index.md \u0026lt;-- /level-one/level-two/level-three/level-four\r│ │ │ │ ├── page-4-a.md \u0026lt;-- /level-one/level-two/level-three/level-four/page-4-a\r│ │ │ │ ├── page-4-b.md \u0026lt;-- /level-one/level-two/level-three/level-four/page-4-b\r│ │ │ │ └── page-4-c.md \u0026lt;-- /level-one/level-two/level-three/level-four/page-4-c\r│ │ │ ├── _index.md \u0026lt;-- /level-one/level-two/level-three\r│ │ │ ├── page-3-a.md \u0026lt;-- /level-one/level-two/level-three/page-3-a\r│ │ │ ├── page-3-b.md \u0026lt;-- /level-one/level-two/level-three/page-3-b\r│ │ │ └── page-3-c.md \u0026lt;-- /level-one/level-two/level-three/page-3-c\r│ │ ├── _index.md \u0026lt;-- /level-one/level-two\r│ │ ├── page-2-a.md \u0026lt;-- /level-one/level-two/page-2-a\r│ │ ├── page-2-b.md \u0026lt;-- /level-one/level-two/page-2-b\r│ │ └── page-2-c.md \u0026lt;-- /level-one/level-two/page-2-c\r│ ├── _index.md \u0026lt;-- /level-one\r│ ├── page-1-a.md \u0026lt;-- /level-one/page-1-a\r│ ├── page-1-b.md \u0026lt;-- /level-one/page-1-b\r│ └── page-1-c.md \u0026lt;-- /level-one/page-1-c\r├── _index.md \u0026lt;-- /\r└── page-top.md \u0026lt;-- /page-top\r_index.md is required in each folder, it’s your “folder home page”\nPages The theme that we\u0026rsquo;re using defines two types of pages. Default and Chapter. Both can be used at any level of the documentation, the only difference being layout display.\nChapters A Chapter displays a page meant to be used as introduction for a set of child pages. Commonly, it contains a simple title and a catch line to define content that can be found under it.\n--- title: Contribute weight: 2 chapter: true --- ### Chapter 2 # Contribute Discover how you can contribute! To consider a page as a chapter, set chapter=true in the Front Matter of the page.\nDefault pages A Default page is any other content page.\n--- date: 2016-04-09T16:50:16+02:00 title: Advanced display configuration options weight: 40 --- ## Advanced configuration options Content Now you can add your content (or update existing ones) to the pages that you want.\nBuilding the docs website In order to build and submit your changes, please follow the instructions below:\nFork the flogo repo Update the docs with your content Create a PR against the flogo repo "
},
{
	"uri": "https://tibcosoftware.github.io/contributing/contribute-to-showcase/",
	"title": "Contributing to the Showcase",
	"tags": [],
	"description": "",
	"content": "Have an activity, trigger or app that you want to share with the Flogo comunity? That\u0026rsquo;s awesome! To contribute to the showcase follow the steps below.\nFolders The showcase is located at the root of the flogo repo and is structured as follows.\nshowcases\r├── data │ ├── items.toml \u0026lt;-- the showcase data file\ritems.toml is the file that you\u0026rsquo;ll need to edit to add your activity, trigger or app.\nAdding your contribution After you\u0026rsquo;ve forked the flogo repo and cloned it to your local machine, open showcases/data/items.toml in your favorite text editor. You can search to see if your contribution has been listed already or simply append your specific contribution, as shown below.\n[[items]] name = \u0026#34;Aggregate\u0026#34; type = \u0026#34;activity\u0026#34; description = \u0026#34;This activity provides your flogo application with rudimentary aggregation capabilities.\u0026#34; url = \u0026#34;https://github.com/TIBCOSoftware/flogo-contrib/tree/master/activity/aggregate\u0026#34; uploadedon = \u0026#34;January 8, 2018\u0026#34; author = \u0026#34;TIBCOSoftware\u0026#34; showcase = \u0026#34;true\u0026#34; Enter your contribution name Specify the type: activity, trigger or app Supply a short description Provide the GitHub url Specify your uploaded date Provide your github id display your contribution in the showcase Building the showcase In order to build and submit your changes, please follow the instructions below:\nFork the flogo repo Update the showcase with your content, as shown above Create a PR against the flogo repo Automatic updates Flogo checks for activity updates and new activities once per day and automatically adds them to the items.toml file. By default new additions will not be visible in the showcase, unless the author of the contribution submits a PR to the Flogo repository to do so. Flogo automatically removes contributions that are no longer on GitHub.\n"
},
{
	"uri": "https://tibcosoftware.github.io/glossary/",
	"title": "Glossary",
	"tags": [],
	"description": "",
	"content": "Flogo terminology and constructs, defined here, all in one place in a logical order vs alphabetical.\nApp An application in Flogo terms is comprised of one or more triggers and flows (actions). The application itself is really just an organizational mechanism that can be leveraged when developing microservices \u0026amp; functions. An application contains a set of configurations, as well as triggers and a collection of flows.\nTrigger Flogo is an event-driven framework. A trigger is the entrypoint for events. A trigger can be a subscriber on an MQTT topic, Kafka topic, HTTP REST interface or a specific IoT sensor. The trigger is responsible for accepting the incoming event and invoking one or more defined actions (flows).\nTriggers are not coupled to flows, that is, a flow can exist without a trigger.\nHandlers The trigger handler is used to map triggers to actions (flows) for processing. A trigger can have one or more handlers that can route events to different flows.\nAction As stated in the triggers section above, Flogo is an event-driven framework. Incoming events can be mapped to an action. An action is a generic implementation for processing the incoming event. Different types of actions can be implemented, thus defining different methods by which an incoming event can be processed.\nToday, only a single action type has been implemented - the Flow.\nFlow A flow is an implementation of an action and is the primary tool to implement business logic in Flogo. A flow can consist of a number of different constructs:\nOne or more activities that implement specific logic (for example write to a database, invoke a REST endpoint, etc) Each activity is connected via a link Links can contain conditional logic to alter the path of a flow Flows, as previously stated in the triggers section, can exist without a trigger. Thus, flows operate very similar to functions, that is, a single flow can define its own input \u0026amp; output parameters. Thus, enabling a flow to be reused regardless of the trigger entrypoint. All logic in the flow only operates against the following data:\nFlow input parameters Environment variables Application properties The output data from activities referenced in the flow The flow cannot access trigger data directly, trigger input and output data must be mapped into the flows input and output parameters. Refer to Development \u0026gt; Flows \u0026gt; Mappings\nMapping The phrase mapping occurs quite often and refers to the concept of taking properties from one object and associating them with properties of another object. For example, consider object A exposes two properties and activity B accepts only a single input parameter, the two properties need to be concatenated (for example) and \u0026lsquo;mapped\u0026rsquo; into the single input of activity B.\nActivity An activity is the unit of work that can be leveraged within a Flow. An activity can be any number of things and can be compared to a simple function in Go or any other procedural language, that is, an activity accepts input params and will return one or more objects on return, both input \u0026amp; output params are defined by the activity metadata.\n"
},
{
	"uri": "https://tibcosoftware.github.io/contributing/contributing/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "THIS PAGE IS AUTOMATICALLY GENERATED DURING BUILD\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo-cli/dev-plugin/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "THIS PAGE IS AUTOMATICALLY GENERATED DURING BUILD\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo-cli/flogo-cli/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "THIS PAGE IS AUTOMATICALLY GENERATED DURING BUILD\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo-cli/plugins/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "THIS PAGE IS AUTOMATICALLY GENERATED DURING BUILD\n"
},
{
	"uri": "https://tibcosoftware.github.io/introduction/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "THIS PAGE IS AUTOMATICALLY GENERATED DURING BUILD\n"
},
{
	"uri": "https://tibcosoftware.github.io/labs/aws-iot/",
	"title": "AWS IoT",
	"tags": [],
	"description": "",
	"content": "A device shadow is a digital representation in the cloud that stores and retrieves current state information for a device. You can get and set the state of a device over MQTT or HTTP, even if the device isn\u0026rsquo;t connected to the Internet.\nWhat you\u0026rsquo;ll need The Flogo Web UI This demo makes use of the Flogo Web UI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo Web UI\nCertificates The AWS IoT Device Shadow service requires a very specific setup to make use of SSL certificates. You\u0026rsquo;ll need to download the AWS IoT certificate and private key files. You\u0026rsquo;ll need to put everything in a special folder too, but you\u0026rsquo;ll be able to do that later.\nStep 1: Create the app Open the Flogo Web UI and from there, click \u0026ldquo;New\u0026rdquo; to create a new microservice and give your new app a name. Click \u0026ldquo;Create a Flow\u0026rdquo; to create a new flow and give it any name that you want. Now click on the flow you just created and to open the canvas where you can design your flow.\nStep 2: Add a trigger Triggers are used to signal a flow to run. In this case you want to receive an HTTP message to update the device shadow. To add a trigger, click on the \u0026ldquo;+\u0026rdquo; icon on the left hand side of the screen and select the Receive HTTP Message trigger.\nThe response to the HTTP request will be a message and the HTTP status code, and to be able to send data back you\u0026rsquo;ll need to have Output parameters. You can create them by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen. From there, select Output and configure two parameters:\nParameter name: code Type: integer Now click on the + sign to add a new parameter\nParameter name: message Type: string Now it is time to configure the trigger to listen to HTTP messages. To start, click on the trigger and a new dialog will open with a bunch of options. In this dialog you\u0026rsquo;ll have to provide:\nPort: The port on which your app will listen (set this to 9233) Method: The HTTP method that will trigger this flow (set this to GET) Path: The path that will route the messages to this flow (this can be anything, like /awsiot/status) After that, click on \u0026ldquo;Map to flow outputs\u0026rdquo; to map the output parameters you created earlier to the response of the trigger. The code parameter will already be selected, so click on \u0026ldquo;123 code\u0026rdquo; in the Flow Output section to create the mapping. Now click on \u0026ldquo;message\u0026rdquo; in the Trigger Response section and select \u0026ldquo;* data\u0026rdquo; from the Flow Output section to create the mapping. Click \u0026ldquo;save\u0026rdquo; to make sure everything is, well…, saved. You can click the little X on the top-right (no, not your browser…) to close the dialog window and go back to the flow.\nStep 3: Add activities You’ll have to add some activities to the flow for it to do something. To add an activity click on the large + sign\nA list with all the activities the Flogo Web UI knows about will appear. From the list you can pick the \u0026ldquo;Log Message\u0026rdquo; activity (or use the searchbar to find it) and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Log Message\u0026rdquo; activity. Click on \u0026ldquo;a.. message\u0026rdquo; and type Received Rest request and starting trigger. in the box (on the right hand side of the screen).\nIn the same way you just added the Log activity, now add a Update AWS Device Shadow activity and configure it in the same way with:\nthing: flogo_test (or the name of the device shadow you want to update) awsEndpoint: the MQTT endpoint for your device shadow desired: A JSON representation of the desired state of your device (for example {\u0026quot;switch\u0026quot;:\u0026quot;on\u0026quot;}) reported: A JSON representation of the current state of your device (for example {\u0026quot;switch\u0026quot;:\u0026quot;off\u0026quot;}) This will tell the AWS IoT device shadow to update the reported state into the desired state and as soon as the thing connects to AWS IoT it will receive the new desired state and try to update itself.\nAdd another Log Message activity, but this time with the message Set Report to off and desired to on\nStep 4: Return to sender To complete the app, add a Return activity. Hover over it to see the cog and select configure to bring up the modal to configure the activity. The return activity is always the last activity in a branch and sets the values that are returned to the trigger. Click on \u0026ldquo;123 code\u0026rdquo; and type 200 in the input field to set the HTTP Response code to 200. Now click on \u0026ldquo;a.. message\u0026rdquo; and type \u0026quot;AWS IOT update successful\u0026quot; in the input field (the quotes are needed). Finally click \u0026ldquo;Save\u0026rdquo; to complete the mapping.\nWith all the updates, your flow should look something like the one below.\nStep 5: Build Those were all the steps needed to design the flow, now let\u0026rsquo;s build an executable from it. On the main screen of your flow click on the \u0026lt; button on the top-left hand side of the screen. Click on build and select your operating system of choice!\nStep 6: Run To run the app you\u0026rsquo;ll need to create on the below structure on disk:\n├── \u0026lt;app\u0026gt; \u0026lt;-- Your Flogo app ├── things \u0026lt;-- A folder called things │ ├── root-CA.pem.crt \u0026lt;-- The AWS IoT root certificate (you\u0026#39;ll have to rename it to \u0026#39;root-CA.pem.crt\u0026#39;) │ ├── flogo \u0026lt;-- The name of the thing name (in this case the thing would be called flogo) │ │ ├── device.pem.crt \u0026lt;-- The AWS IoT device certificate (you\u0026#39;ll have to rename it to \u0026#39;device.pem.crt\u0026#39;) │ │ ├── device.pem.key \u0026lt;-- The AWS IoT private key (you\u0026#39;ll have to rename it to \u0026#39;device.pem.key\u0026#39;) After you start the app, you can send POST requests to it like curl --request GET --url http://localhost:9233/awsiot/status --header 'content-type: application/json' --data '{\u0026quot;switch\u0026quot;: \u0026quot;on\u0026quot;}'\n"
},
{
	"uri": "https://tibcosoftware.github.io/labs/bookstore/",
	"title": "Bookstore",
	"tags": [],
	"description": "",
	"content": "Who doesn\u0026rsquo;t like a good book? But what if you really, really need to get some information about a book first? In that case you build a Flogo app that uses the Google APIs to get book information!\nWhat you\u0026rsquo;ll need The Flogo Web UI This demo makes use of the Flogo Web UI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo Web UI\nStep 1: Create the app Open the Flogo Web UI and from there, click \u0026ldquo;New\u0026rdquo; to create a new microservice and give your new app a name. Click \u0026ldquo;Create a Flow\u0026rdquo; to create a new flow and give it any name that you want. Now click on the flow you just created and to open the canvas where you can design your flow.\nStep 2: Add a trigger Triggers are used to signal a flow to run. In this case you want to receive an HTTP message to update the device shadow. To add a trigger, click on the \u0026ldquo;+\u0026rdquo; icon on the left hand side of the screen and select the Receive HTTP Message trigger.\nThe thing you need to send to the Google Books API is the isbn coming from the HTTP request. To do so, you\u0026rsquo;ll need to create an Input parameter which you can do by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen. For example, you can call the parameter \u0026ldquo;isbn\u0026rdquo;, keep the type as \u0026ldquo;string\u0026rdquo; and click save.\nThe response to the HTTP request will be a message and the HTTP status code, and to be able to send data back you\u0026rsquo;ll need to have Output parameters. From the screen where you are now, select Output and configure two parameters:\nParameter name: code Type: integer Now click on the + sign to add a new parameter\nParameter name: message Type: any Now it is time to configure the trigger to listen to HTTP messages. To start, click on the trigger and a new dialog will open with a bunch of options. In this dialog you\u0026rsquo;ll have to provide:\nPort: The port on which your app will listen (set this to 9233) Method: The HTTP method that will trigger this flow (set this to GET) Path: The path that will route the messages to this flow (set this to /books/:isbn, the :isbn means that you can use that as a path parameter in your mappings). After that, click on \u0026ldquo;Map to flow inputs\u0026rdquo; to map the isbn from the HTTP trigger to the \u0026ldquo;isbn\u0026rdquo; parameter we created earlier. The parameter will already be selected because it is the only one. You\u0026rsquo;ll need to concatenate isbn: with the actual number so you\u0026rsquo;ll need to type (or paste) the following string.concat(\u0026quot;isbn:\u0026quot;, $.pathParams.isbn).\nNow for the outputs, click on \u0026ldquo;Map to flow outputs\u0026rdquo; to map the output parameters you created earlier to the response of the trigger. The code parameter will already be selected, so click on \u0026ldquo;123 code\u0026rdquo; in the Flow Output section to create the mapping. Now click on \u0026ldquo;message\u0026rdquo; in the Trigger Response section and select \u0026ldquo;* data\u0026rdquo; from the Flow Output section to create the mapping. Click \u0026ldquo;save\u0026rdquo; to make sure everything is, well…, saved. You can click the little X on the top-right (no, not your browser…) to close the dialog window and go back to the flow.\nStep 3: Adding activities You’ll have to add some activities to the flow for it to do something. To add an activity click on the large + sign\nOn the right-hand side of the screen a list with all the activities the Flogo Web UI knows about will appear. From the list you can pick the \u0026ldquo;Log Message\u0026rdquo; activity and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Log Message\u0026rdquo; activity using data from all other activities and triggers in your flow. Right now, you only have the incoming data from the HTTP trigger. To make the log message a little more useful you can concatenate things together like in the HTTP trigger. To do so select the concat function from the string category (see #1), which will put a new function in the window. Now replace str1 with \u0026quot;Getting book data for: \u0026quot;, as that will be the first part of the message to log (see #2). The second part will be the isbn. To get the isbn on the place of str2, select str2 first and after that expand the \u0026ldquo;flow (flow)\u0026rdquo; section (by clicking on the little black caret) and click \u0026ldquo;a.. isbn\u0026rdquo; (see #3). That will enter the selected value on the place of str2 (see #4).\nStep 4: Invoking a REST service The Google API for books is a REST service. To invoke a REST service you can add a new Invoke REST Service activity. As you hover over it to configure the values, you\u0026rsquo;ll notice this activity has a lot more fields you can configure. For now the configuration should be:\nmethod: \u0026quot;GET\u0026quot; (to get data from the API) uri: https://www.googleapis.com/books/v1/volumes (the URL of the service you want to call) queryParams: {\u0026quot;q\u0026quot;:\u0026quot;=$flow.isbn\u0026quot;} (this appends a query parameter called q with the value of the isbn to the URL) Step 5: Return data To complete the flow, add a Return activity. Hover over it to see the cog and select configure to bring up the modal to configure the activity. The return activity is always the last activity in a branch and sets the values that are returned to the trigger. Click on \u0026ldquo;123 code\u0026rdquo; and type 200 in the input field to set the HTTP Response code to 200.\nNow click on \u0026ldquo;* message\u0026rdquo; and type (or copy) the structure below. Finally click \u0026ldquo;Save\u0026rdquo; to complete the mapping.\n{ \u0026#34;title\u0026#34;: \u0026#34;=$activity[rest_3].result.items[0].volumeInfo.title\u0026#34;, \u0026#34;publishedDate\u0026#34;: \u0026#34;=$activity[rest_3].result.items[0].volumeInfo.publishedDate\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;=$activity[rest_3].result.items[0].volumeInfo.description\u0026#34; } The above snippet maps the values from the REST service to fields that are sent back to the trigger. The mapping is done in a JavaScript-like syntax, so $activity[rest_3].result.items[0].volumeInfo.title means it will get the first result (arrays start with 0) and from that result get the volumeInfo element and from that get the title element. The double curly braces are used as by Go\u0026rsquo;s templating engine.\nYour final flow should look something like the one below.\nStep 6: Build Those were all the steps needed to design the flow, now let\u0026rsquo;s build an executable from it. On the main screen of your flow click on the \u0026ldquo;\u0026lt;\u0026rdquo; button on the top-left hand side of the screen. That will bring you back to your microservice and from here you can select \u0026ldquo;Build\u0026rdquo;. Choose whichever operating system you\u0026rsquo;re running on to download the executable.\nStep 7: Run To see the results, start your app and run curl --request GET --url http://localhost:9233/books/0747532699. That will give you the details on Harry Potter and the Philosopher\u0026rsquo;s Stone\n"
},
{
	"uri": "https://tibcosoftware.github.io/labs/flogo-cli/",
	"title": "Building apps with Flogo CLI",
	"tags": [],
	"description": "",
	"content": "Project Flogo provides a CLI that gives you the ability to build flogo applications (flows, streams, rules, microgateway). With this tool you can, among other things, create your applications, build applications and install new extensions. This tool is great to use with Continuous Integration and Continuous Deployment tools like Jenkins and Travis-CI.\nIn this tutorial you will learn how to use the flogo cli.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\nThe project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations. Step 1: flogo.json Flogo apps are constructed using a JSON file called flogo.json. You can create those files using the Flogo Web UI, or you can create them manually. Now let\u0026rsquo;s create the flogo.json file. To do that, execute touch flogo.json in a terminal (or open up a new file in your text editor), which will create a new empty file for you.\nNow you can copy the contents below to the newly created flogo.json file. The Flogo app has a REST trigger which listens on port 9233 and the HTTP path /test/:name (where :name is a parameter you can fill in).\n{ \u0026#34;name\u0026#34;: \u0026#34;SampleApp\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;flogo:app\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;appModel\u0026#34;: \u0026#34;1.1.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;imports\u0026#34;: [ \u0026#34;github.com/project-flogo/contrib/activity/log\u0026#34;, \u0026#34;github.com/project-flogo/contrib/trigger/rest\u0026#34;, \u0026#34;github.com/project-flogo/flow\u0026#34; ], \u0026#34;triggers\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;receive_http_message\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;#rest\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Receive HTTP Message\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Simple REST Trigger\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;port\u0026#34;: 8080 }, \u0026#34;handlers\u0026#34;: [ { \u0026#34;settings\u0026#34;: { \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/test\u0026#34; }, \u0026#34;action\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;#flow\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;flowURI\u0026#34;: \u0026#34;res://flow:get_name\u0026#34; }, \u0026#34;input\u0026#34;: { }, \u0026#34;output\u0026#34;: { \u0026#34;code\u0026#34;: 200 } } } ] } ], \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;flow:get_name\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;GetName\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;output\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;greeting\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ] }, \u0026#34;tasks\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;log_2\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Log\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Logs a message\u0026#34;, \u0026#34;activity\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;#log\u0026#34;, \u0026#34;input\u0026#34;: { \u0026#34;message\u0026#34;: \u0026#34;Hello from Flogo\u0026#34;, \u0026#34;addDetails\u0026#34;: false } } } ] } } ] } Step 2: Building an app To create the source code simply execute flogo create -f flogo.json myapp. This tells the Flogo CLI to take the flogo.json file and create the source for the app in a folder called myapp. It will also download a few Go packages that the app will need. The output will look something like:\nflogo create -f /Users/mellis/Downloads/sample_app_1.json myapp Creating Flogo App: myapp Installing: github.com/project-flogo/core@latest Installed trigger: github.com/project-flogo/contrib/trigger/rest Installed action: github.com/project-flogo/flow Installed activity: github.com/project-flogo/contrib/activity/log The next step is to build the executable and for that we need to be in the directory myapp (cd myapp). To build a flogo app from the source you can execute the command flogo build -e, which tells the flogo cli to build the app (and place it in a bin directory) and embed all configuration into a single executable\nStep 3: Running the app You have just built the Flogo app, so now you can test it. From the bin directory (cd bin) you can run ./myapp which will start the app. In the terminal you\u0026rsquo;ll see something like\n2018-05-12 04:34:56.434 INFO [engine] - Engine Starting... 2018-05-12 04:34:56.435 INFO [engine] - Starting Services... 2018-05-12 04:34:56.435 INFO [engine] - Started Services 2018-05-12 04:34:56.435 INFO [engine] - Starting Triggers... 2018-05-12 04:34:56.435 INFO [engine] - Trigger [ receive_http_message ]: Started 2018-05-12 04:34:56.435 INFO [engine] - Triggers Started 2018-05-12 04:34:56.435 INFO [engine] - Engine Started To test it we\u0026rsquo;ll use the curl command line tool, which is installed on most Operating Systems. From a new terminal window execute the command curl http://localhost:8080/test. It will send an HTTP request to the app on port 8080 (which was configured in the flogo.json file). In the first terminal you will see the result of the flow (Hello from Flogo), you\u0026rsquo;ll also see there are additional lines in your window that indicate a flow has been executed.\n2019-05-13T17:40:14.851+0200\tINFO\t[flogo.engine] -\tStarting app [ SampleApp ] with version [ 0.0.1 ] 2019-05-13T17:40:14.851+0200\tINFO\t[flogo.engine] -\tEngine Starting... 2019-05-13T17:40:14.851+0200\tINFO\t[flogo.engine] -\tStarting Services... 2019-05-13T17:40:14.851+0200\tINFO\t[flogo] -\tActionRunner Service: Started 2019-05-13T17:40:14.851+0200\tINFO\t[flogo.engine] -\tStarted Services 2019-05-13T17:40:14.851+0200\tINFO\t[flogo.engine] -\tStarting Application... 2019-05-13T17:40:14.851+0200\tINFO\t[flogo] -\tStarting Triggers... 2019-05-13T17:40:14.851+0200\tINFO\t[flogo] -\tTrigger [ receive_http_message ]: Started 2019-05-13T17:40:14.851+0200\tINFO\t[flogo] -\tTriggers Started 2019-05-13T17:40:14.851+0200\tINFO\t[flogo.engine] -\tApplication Started 2019-05-13T17:40:14.851+0200\tINFO\t[flogo.engine] -\tEngine Started 2019-05-13T17:40:14.851+0200\tINFO\t[flogo] -\tListening on http://0.0.0.0:8080 2019-05-13T17:40:33.456+0200\tINFO\t[flogo.activity.log] -\tHello from Flogo 2019-05-13T17:40:33.456+0200\tINFO\t[flogo.flow] -\tInstance [28ac8005732b92373635a219624031dd] Done "
},
{
	"uri": "https://tibcosoftware.github.io/labs/flogo-lambda/",
	"title": "Building Flogo apps for Lambda",
	"tags": [],
	"description": "",
	"content": "Serverless is all around us and perhaps the fastest growing market for compute. Flogo has first class support for AWS Lambda. So you can infinitely scale your ultralight functions and scale back to zero when not in use with AWS Lambda’s NoOps and seamless scaling capabilities.\nWe’ll guide you through the set of steps required to build the most basic of functions for deployment to AWS Lambda. The flow you’ll build will be the function you deploy.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nAWS CLI To deploy your app at the end of this scenario you\u0026rsquo;ll need the AWS CLI. There are a few ways how you can install the AWS CLI.\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\nThe project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations. Step 1: flogo.json Flogo apps are constructed using a JSON file called flogo.json. You can create those files using the Flogo Web UI, or you can create them manually. Now let\u0026rsquo;s create the flogo.json file. To do that, execute touch flogo.json in a terminal (or open up a new file in your text editor), which will create a new empty file for you.\nNow you can copy the contents below to the newly created flogo.json file. The Flogo app has a Lambda trigger and a PATH parameter called name.\n{ \u0026#34;name\u0026#34;: \u0026#34;Tutorial\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;flogo:app\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;appModel\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;triggers\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;start_flow_as_a_function_in_lambda\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/trigger/lambda\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Start Flow as a function in Lambda\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Simple Lambda Trigger\u0026#34;, \u0026#34;settings\u0026#34;: {}, \u0026#34;handlers\u0026#34;: [ { \u0026#34;action\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/action/flow\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;flowURI\u0026#34;: \u0026#34;res://flow:lambda_flow\u0026#34; }, \u0026#34;mappings\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;mapTo\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;assign\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$.evt.name\u0026#34; } ], \u0026#34;output\u0026#34;: [ { \u0026#34;mapTo\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;assign\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$.greeting\u0026#34; } ] } } } ] } ], \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;flow:lambda_flow\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;LambdaFlow\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;output\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;greeting\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;any\u0026#34; } ] }, \u0026#34;tasks\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;log_2\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Log Message\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Simple Log Activity\u0026#34;, \u0026#34;activity\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026#34;, \u0026#34;input\u0026#34;: { \u0026#34;message\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;flowInfo\u0026#34;: \u0026#34;false\u0026#34;, \u0026#34;addToFlow\u0026#34;: \u0026#34;false\u0026#34; }, \u0026#34;mappings\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;expression\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;string.concat(\\\u0026#34;Hello \\\u0026#34;, $flow.name)\u0026#34;, \u0026#34;mapTo\u0026#34;: \u0026#34;message\u0026#34; } ] } } }, { \u0026#34;id\u0026#34;: \u0026#34;actreturn_3\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Return\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Simple Return Activity\u0026#34;, \u0026#34;activity\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/activity/actreturn\u0026#34;, \u0026#34;input\u0026#34;: { \u0026#34;mappings\u0026#34;: [ { \u0026#34;mapTo\u0026#34;: \u0026#34;greeting\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;value\u0026#34;: {\u0026#34;Hello\u0026#34;: \u0026#34;{{$flow.name}}\u0026#34;} } ] } } } ], \u0026#34;links\u0026#34;: [ { \u0026#34;from\u0026#34;: \u0026#34;log_2\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;actreturn_3\u0026#34; } ] } } ] } Step 2: Building an app To create the source code simply execute flogo create -f flogo.json myapp. This tells the flogo cli to take the flogo.json file and create the source for the app in a folder called myapp. It will also download a few Go packages that the app will need.\nThe next step is to build the executable and for that we need to be in the directory myapp (cd myapp). To build a flogo app from the source that you can run on AWS Lambda we\u0026rsquo;ll need to execute a command that is very similar to the one we had in the cli tutorial, but with some added parameters. The command you need to run is flogo build -e -shim start_flow_as_a_function_in_lambda, which tells the flogo cli to build the app as an embedded application (the -e option) and with a target shim (the -shim option which uses the trigger id). The AWS Lambda trigger leverages a makefile to kick off the build process, which simply builds your Flogo application using the Lambda trigger shim and zips the binary for deployment to AWS Lambda.\nOnce this command finishes successfully the zip file (handler.zip) will be in the src directory.\nStep 3: AWS Lambda Great! So we\u0026rsquo;ve built the zip that we need to deploy to Lambda and that is exactly what we\u0026rsquo;ll do in this step.\nIAM policies and roles Generally speaking it is a good idea to create separate IAM users for deploying to AWS. This allows you to explicitly control which resources a Lambda function can use. For now, you can make use of any IAM user that has the ability to deploy to AWS Lambda and you\u0026rsquo;ll need the Access Key ID and Secret Access Key for this step.\nAs you go on with building apps for Lambda we do strongly recommend looking atht the AWS IAM documentation to find out which policies you need to set for your IAM user.\nFor this tutorial we\u0026rsquo;ll also assume that you have an IAM role with enough permissions to create a Lambda function. If you\u0026rsquo;ve used the AWS Lambda console, there will likely be an IAM role called lambda_basic_execution which you can use for this tutorial. In any case you\u0026rsquo;ll need the ARN of this role later in this step (which you can find in the IAM console).\nConfigure AWS CLI Run the command aws configure to start the configuration of your AWS CLI. You\u0026rsquo;ll be asked to provide:\nAWS Access Key ID AWS Secret Access Key Default region name (the region you want to deploy to, like us-west-2) Default output format (the output format you want, like json) Deploy your app To deploy your app go to the directory where the zip was created. From here you can execute the command aws lambda create-function --function-name tutorial --runtime go1.x --role arn:aws:iam::\u0026lt;account\u0026gt;:role/\u0026lt;role name\u0026gt; --handler handler --zip-file \u0026quot;fileb://handler.zip\u0026quot;. This will create a new function in Lambda called tutorial, which uses the Go runtime. The \u0026ndash;role arn:aws:iam:::role/ is the full ARN of the IAM role used to deploy this function. If all went well you\u0026rsquo;ll see a JSON response like this:\n{ \u0026#34;TracingConfig\u0026#34;: { \u0026#34;Mode\u0026#34;: \u0026#34;PassThrough\u0026#34; }, \u0026#34;CodeSha256\u0026#34;: \u0026#34;KzHoXLnTXi9uMugXAOLrMHq6qJ6RimzYdNfrWXIxwLw=\u0026#34;, \u0026#34;FunctionName\u0026#34;: \u0026#34;tutorial\u0026#34;, \u0026#34;CodeSize\u0026#34;: 4026592, \u0026#34;RevisionId\u0026#34;: \u0026#34;94b184e5-74e3-4881-abf5-debad47541b5\u0026#34;, \u0026#34;MemorySize\u0026#34;: 128, \u0026#34;FunctionArn\u0026#34;: \u0026#34;arn:aws:lambda:\u0026lt;region\u0026gt;:\u0026lt;account\u0026gt;:function:tutorial\u0026#34;, \u0026#34;Version\u0026#34;: \u0026#34;$LATEST\u0026#34;, \u0026#34;Role\u0026#34;: \u0026#34;arn:aws:iam::\u0026lt;account\u0026gt;:role/\u0026lt;role\u0026gt;\u0026#34;, \u0026#34;Timeout\u0026#34;: 3, \u0026#34;LastModified\u0026#34;: \u0026#34;2018-05-12T19:30:41.116+0000\u0026#34;, \u0026#34;Handler\u0026#34;: \u0026#34;handler\u0026#34;, \u0026#34;Runtime\u0026#34;: \u0026#34;go1.x\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;\u0026#34; } Step 4: Testing The only thing left is to test your function. To do that log into AWS and select \u0026ldquo;Lambda\u0026rdquo;, you\u0026rsquo;ll be presented with all the functions you\u0026rsquo;ve deployed so far and one of them will be called tutorial. Click on that, and you\u0026rsquo;ll see the overview of your function, including a large button that says \u0026ldquo;Test\u0026rdquo;. Click \u0026ldquo;Test\u0026rdquo; to configure a new test event. The input for the test event should be (you can replace \u0026ldquo;world\u0026rdquo; with any name or message you want)\n{ \u0026#34;name\u0026#34;: \u0026#34;World\u0026#34; } From there, click \u0026ldquo;Test\u0026rdquo; and the execution logs will display the result\n{ \u0026#34;Hello\u0026#34;: \u0026#34;World\u0026#34; } And the log output\nSTART RequestId: 4f26990d-561d-11e8-96ca-bb9eb4465310 Version: $LATEST 2018-05-12 19:47:31.969 INFO [trigger-flogo-lambda] - Starting AWS Lambda Trigger 2018/05/12 19:47:31 Starting AWS Lambda Trigger 2018/05/12 19:47:31 Received evt: \u0026#39;map[name:World]\u0026#39; 2018/05/12 19:47:31 Received ctx: \u0026#39;map[logStreamName:2018/05/12/[$LATEST]7f886628e07a4256b0f411b6cd3b6915 memoryLimitInMB:128 awsRequestId:4f26990d-561d-11e8-96ca-bb9eb4465310 functionName:tutorial functionVersion:$LATEST logGroupName:/aws/lambda/tutorial]\u0026#39; 2018-05-12 19:47:31.969 INFO [activity-flogo-log] - Hello World $flow.nameEND RequestId: 4f26990d-561d-11e8-96ca-bb9eb4465310 REPORT RequestId: 4f26990d-561d-11e8-96ca-bb9eb4465310\tDuration: 1.63 ms\tBilled Duration: 100 ms Memory Size: 128 MB\tMax Memory Used: 23 MB As you\u0026rsquo;re glancing over the results, also look at the Duration and Max Memory Used. Isn\u0026rsquo;t that one of the smallest functions you\u0026rsquo;ve seen?!\n"
},
{
	"uri": "https://tibcosoftware.github.io/labs/building-activities/",
	"title": "Building your first activity",
	"tags": [],
	"description": "",
	"content": "Project Flogo exposes a number of different extension points, in this tutorial we\u0026rsquo;ll explore the activity contribution point and learn how to build a custom activity in Go.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\nThe project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations. Generate the basic framework The easiest way to start creating activities is to clone the content of the project-flogo/core/examples/activity. In this tutorial you\u0026rsquo;ll build an activity that takes 2 input parameters (name and salutation) and logs that to the console. It will also return the concatenation of the two fields to you. To start you should pull the example activity from flogo core:\ngit clone https://github.com/project-flogo/core cp -R core/examples/activity/* /myNewActivity The metadata The first step is to update the file descriptor.json, which has the metadata for your new Flogo activity, with proper information. The metadata describes to the Flogo Web UI what the activity is called, what the version of the activity is and a few other things, such as the input and output. The elements in the file are:\nname: The name of the activity (this should match the name of the folder the activity is in, like HelloWorld) version: The version of the activity (it is recommended to use semantic versioning for your activities) type: This describes the type of contribution this is (this should be flogo:activity in this case) title: The application title to display in the web ui ref: The Go package reference that will be used by the web ui to fetch the contribution upon installation description: A brief description of your activity (this is displayed in the Flogo Web UI) author: This is you! settings: An array of name/type pairs that describe the activity settings. Note that activity settings are pre-compiled settings and can be used to increased performance. Settings are not fetched for every invocation input: An array of name/type pairs that describe the input to the activity output: An array of name/type pairs that describe the output to the activity Since you\u0026rsquo;ll want to provide some inputs, you\u0026rsquo;ll need to update the inputs and outputs section\nThe input needs a anInput param (should be of type string) The output section needs a parameter called anOutput (should be of type string) Don\u0026rsquo;t forget to update the author, ref, and description fields, as well! For Flogo Web UI, add a title field to label and help find your activity.\nThe updated descriptor.json will look quite similar to the below one.\n{ \u0026#34;name\u0026#34;: \u0026#34;sample-activity\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;flogo:activity\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Sample Activity\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Sample Activity\u0026#34;, \u0026#34;homepage\u0026#34;: \u0026#34;https://github.com/project-flogo/tree/master/examples/activity\u0026#34;, \u0026#34;settings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;aSetting\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;required\u0026#34;: true } ], \u0026#34;input\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;anInput\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;required\u0026#34;: true } ], \u0026#34;output\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;anOutput\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ] The logic For the Flogo engine to actually do something we need to update the *.go files. There are two files in your current directory:\nactivity.go: which contains the actual activity implementation in go activity_test.go: which contains unit tests for the activity metadata.go: which contains the basic input/output/settings metadata. This is used by the engine The first step is to define our input/output/setting metadata.go. This is used by the engine and also used when leveraging contributions using the Flogo Go Lib. This enables Go developers to leverage strongly typed objects for IDE autocompletion, etc.\npackage sample import \u0026#34;github.com/project-flogo/core/data/coerce\u0026#34; type Settings struct { ASetting string `md:\u0026#34;aSetting,required\u0026#34;` } type Input struct { AnInput string `md:\u0026#34;anInput,required\u0026#34;` } func (r *Input) FromMap(values map[string]interface{}) error { strVal, _ := coerce.ToString(values[\u0026#34;anInput\u0026#34;]) r.AnInput = strVal return nil } func (r *Input) ToMap() map[string]interface{} { return map[string]interface{}{ \u0026#34;anInput\u0026#34;: r.AnInput, } } type Output struct { AnOutput string `md:\u0026#34;anOutput\u0026#34;` } func (o *Output) FromMap(values map[string]interface{}) error { strVal, _ := coerce.ToString(values[\u0026#34;anOutput\u0026#34;]) o.AnOutput = strVal return nil } func (o *Output) ToMap() map[string]interface{} { return map[string]interface{}{ \u0026#34;anOutput\u0026#34;: o.AnOutput, } } The next step is to look at the business logic, in the activity.go file.\npackage sample import ( \u0026#34;github.com/project-flogo/core/activity\u0026#34; \u0026#34;github.com/project-flogo/core/data/metadata\u0026#34; ) func init() { _ = activity.Register(\u0026amp;Activity{}) //activity.Register(\u0026amp;Activity{}, New) to create instances using factory method \u0026#39;New\u0026#39; } var activityMd = activity.ToMetadata(\u0026amp;Settings{}, \u0026amp;Input{}, \u0026amp;Output{}) //New optional factory method, should be used if one activity instance per configuration is desired func New(ctx activity.InitContext) (activity.Activity, error) { s := \u0026amp;Settings{} err := metadata.MapToStruct(ctx.Settings(), s, true) if err != nil { return nil, err } ctx.Logger().Debugf(\u0026#34;Setting: %s\u0026#34;, s.ASetting) act := \u0026amp;Activity{} //add aSetting to instance return act, nil } // Activity is an sample Activity that can be used as a base to create a custom activity type Activity struct { } // Metadata returns the activity\u0026#39;s metadata func (a *Activity) Metadata() *activity.Metadata { return activityMd } // Eval implements api.Activity.Eval - Logs the Message func (a *Activity) Eval(ctx activity.Context) (done bool, err error) { input := \u0026amp;Input{} err = ctx.GetInputObject(input) if err != nil { return true, err } ctx.Logger().Debugf(\u0026#34;Input: %s\u0026#34;, input.AnInput) output := \u0026amp;Output{AnOutput: input.AnInput} err = ctx.SetOutputObject(output) if err != nil { return true, err } return true, nil } To make sure that you can test and build the new activity, you\u0026rsquo;ll need to go get (pun intended) a few packages\ngo get github.com/project-flogo/core/activity go get github.com/project-flogo/core/data/coerce go get github.com/project-flogo/core/data/metadata Unit testing You\u0026rsquo;ve just completed the logic of the activity and, following best practice, you should have an automated way to test the activity to make sure that the it works and so that other developers can run the same tests to validate the output as well. The activity_test.go file looks like:\npackage sample import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/project-flogo/core/activity\u0026#34; \u0026#34;github.com/project-flogo/core/support/test\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; ) func TestRegister(t *testing.T) { ref := activity.GetRef(\u0026amp;Activity{}) act := activity.Get(ref) assert.NotNil(t, act) } func TestEval(t *testing.T) { act := \u0026amp;Activity{} tc := test.NewActivityContext(act.Metadata()) input := \u0026amp;Input{AnInput: \u0026#34;test\u0026#34;} err := tc.SetInputObject(input) assert.Nil(t, err) done, err := act.Eval(tc) assert.True(t, done) assert.Nil(t, err) output := \u0026amp;Output{} err = tc.GetOutputObject(output) assert.Nil(t, err) assert.Equal(t, \u0026#34;test\u0026#34;, output.AnOutput) } In order to run the test cases you\u0026rsquo;ll need to intall two more packages. One to be able to run the tests and one to be able to create assertions.\ngo get github.com/project-flogo/core/activity go get github.com/project-flogo/core/support/test go get github.com/stretchr/testify/assert To run all the test cases for your activity, in this case just one, simply enter\ngo test and if all goes well the result should look like\nPASS ok _/C_/tools/gosrc/HelloWorld 0.051s Use your new activity in a flow Now the only thing left to do is use the activity inside a Flogo app! You have two options, install the new activity using the Flogo CLI or via the Web UI. In any case you\u0026rsquo;ll first want to publish your activity to a Git repo (the same one you\u0026rsquo;ve used in the ref field in the descriptor.json). To add the new activity to a Flogo engine and use it in a flow you can import it using the following flogo CLI command, from your flow app directory):\nflogo install github.com/yourusername/yourrepository or import it using the \u0026ldquo;Install new activity\u0026rdquo; option in the Flogo Web UI, where you\u0026rsquo;ll need to provide the URL https://github.com/yourusername/yourrepository.\n"
},
{
	"uri": "https://tibcosoftware.github.io/labs/building-triggers/",
	"title": "Building your first trigger",
	"tags": [],
	"description": "",
	"content": "Project Flogo provides two different command-line interfaces and which you need depends on the task you need to execute.\nflogo: This CLI gives you the ability to build flows and microservices. With this tool you can, among other things, create your applications, build applications and install new extensions. This tool is great to use with Continuous Integration and Continuous Deployment tools like Jenkins and Travis-CI. flogogen: If you’re looking to extend the functionality that Project Flogo offers out of the box, this is the tool you want to use. Flogogen generates the scafolding used by extensions (activity/trigger) developers to build new extensions. In this tutorial you will learn how to use the flogogen tool.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\nThe project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations. Generate the basic framework The easiest way to start creating activities is to have the flogogen CLI create the basic framework for you. The flogogen CLI takes two important parameters to create the framework for triggers. Timers are great to schedule stuff, and a great way to learn new technology, so in this tutorial you\u0026rsquo;ll build a new timer trigger that runs on a specified interval. To start you need to use flogogen to create the scaffolding:\nflogogen trigger \u0026lt; name \u0026gt; The parameters are:\ntrigger: because you want to create a trigger \u0026lt; name \u0026gt;: the name for your new trigger (in this example you\u0026rsquo;ll use MyTimerTrigger as the name for the trigger to make sure it doesn\u0026rsquo;t clash with the existing timer) So to generate our scaffolding, you need to execute the command:\nflogogen trigger MyTimerTrigger The flogogen command will create a folder called MyTimerTrigger and generate the files you need to implement your logic:\nMyTimerTrigger ├── trigger.go \u0026lt;-- The implementation of your trigger ├── trigger.json \u0026lt;-- The metadata of your trigger └── trigger_test.go \u0026lt;-- A file used to test your trigger The metadata The first step is to update the file trigger.json, which has the metadata for your new Flogo activity, with proper information. The metadata describes to the Flogo engine what the activity is called, what the version of the activity is and a few other things. The elements in the file are:\nname: The name of the activity (this should match the name of the folder the activity is in, like MyTimerTrigger) version: The version of the activity (it is recommended to use semantic versioning for your trigger) type: This describes to the Flogo engine what kind of contribution this is (this should be trigger in this case) ref: The Flogo engine is based on Go and this field is the \u0026ldquo;import\u0026rdquo; path for Go apps (generally speaking this should match your repository) description: A brief description of your activity (this is displayed in the Flogo Web UI) author: This is you! settings: An array of name/type pairs that describe global settings of the trigger (configuration that will be the same for every instance of this trigger used in your app) output: An array of name/type pairs that describe the output of the trigger (the data that gets sent to your flow) handler: An array of name/type pairs that describe flow specific settings of the trigger (configuration that will be unique for every instance of this trigger used in your app) Since you\u0026rsquo;ll want to provide some configuration, you\u0026rsquo;ll need to update the outputs section\nThe settings section will be left empty (you\u0026rsquo;ll use flow specific settings) The output section needs a parameter called output (should be of type string) The handler/settings section needs a parameter called seconds (should be of type string) Don\u0026rsquo;t forget to update the author, ref, and description fields, as well!\nThe updated trigger.json will look quite similar to the below one.\n{ \u0026#34;name\u0026#34;: \u0026#34;MyTimerTrigger\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;flogo:trigger\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is a new Timer\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;github.com/yourusername/yourrepository\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Flogo Dev\u0026#34;, \u0026#34;settings\u0026#34;:[ ], \u0026#34;output\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;output\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;handler\u0026#34;: { \u0026#34;settings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;seconds\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ] } } The logic For the Flogo engine to actually do something we need to update the *.go files. There are two files in your current directory:\ntrigger.go: which contains the actual trigger implementation in go trigger_test.go: which contains unit tests for the trigger The first step is to look at the business logic, in the trigger.go file.\nTo begin there are a few packages you\u0026rsquo;ll need to import to make sure the code will work:\n\u0026#34;context\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/TIBCOSoftware/flogo-lib/core/trigger\u0026#34; \u0026#34;github.com/TIBCOSoftware/flogo-lib/logger\u0026#34; \u0026#34;github.com/carlescere/scheduler\u0026#34; As you want to log output to the console you\u0026rsquo;ll need to add a new variable called log to the main part of the file\n// Create a new logger var log = logger.GetLogger(\u0026#34;trigger-mytrigger\u0026#34;) The struct called MyTrigger needs a few more fields to keep track of all the different elements it needs to know about. You\u0026rsquo;ll need to add the timers and handlers so that the engine knows which timers exist and which flows to call when a timer runs.\n// MyTrigger is a stub for your Trigger implementation type MyTrigger struct { metadata *trigger.Metadata config *trigger.Config timers []*scheduler.Job handlers []*trigger.Handler } In the Initialize method you\u0026rsquo;ll need to add one statement to make sure that the trigger can get all the handlers it should know about from the context object.\nt.handlers = ctx.GetHandlers() The Start method implements the logic required to start the various timers you might create in your app and for each it will schedule a job (using the scheduleRepeating method)\n// Start implements trigger.Trigger.Start func (t *MyTrigger) Start() error { log.Debug(\u0026#34;Start\u0026#34;) handlers := t.handlers log.Debug(\u0026#34;Processing handlers\u0026#34;) for _, handler := range handlers { t.scheduleRepeating(handler) } return nil } The scheduleRepeating method is used to schedule a repeating job with a specified time interval. The variable called fn2 is executed when a timer fires and calls the flow it should trigger with the data specified in the map triggerData. The map contains a field called output which matches the name in the trigger.json file.\nfunc (t *MyTrigger) scheduleRepeating(endpoint *trigger.Handler) { log.Info(\u0026#34;Scheduling a repeating job\u0026#34;) fn2 := func() { // Create a map to hold the trigger data triggerData := map[string]interface{}{ \u0026#34;output\u0026#34;: \u0026#34;Hello World from the new Timer Trigger\u0026#34;, } _, err := endpoint.Handle(context.Background(), triggerData) if err != nil { log.Error(\u0026#34;Error running handler: \u0026#34;, err.Error()) } } t.scheduleJobEverySecond(endpoint, fn2) } Finally, you\u0026rsquo;ll need to add a method called scheduleJobEverySecond to make sure the engine checks the timers on a regular basis and executes the function to trigger a flow.\nfunc (t *MyTrigger) scheduleJobEverySecond(tgrHandler *trigger.Handler, fn func()) { var interval int = 0 seconds, _ := strconv.Atoi(tgrHandler.GetStringSetting(\u0026#34;seconds\u0026#34;)) interval = interval + seconds log.Debug(\u0026#34;Repeating seconds: \u0026#34;, interval) // schedule repeating timerJob, err := scheduler.Every(time.Duration(interval)).Seconds().Run(fn) if err != nil { log.Error(\u0026#34;Error scheduleRepeating (repeat seconds) flo err: \u0026#34;, err.Error()) } if timerJob == nil { log.Error(\u0026#34;timerJob is nil\u0026#34;) } t.timers = append(t.timers, timerJob) } The completed file will look something like:\npackage MyTimerTrigger import ( \u0026#34;context\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/TIBCOSoftware/flogo-lib/core/trigger\u0026#34; \u0026#34;github.com/TIBCOSoftware/flogo-lib/logger\u0026#34; \u0026#34;github.com/carlescere/scheduler\u0026#34; ) // Create a new logger var log = logger.GetLogger(\u0026#34;trigger-mytrigger\u0026#34;) // MyTriggerFactory My Trigger factory type MyTriggerFactory struct { metadata *trigger.Metadata } // NewFactory create a new Trigger factory func NewFactory(md *trigger.Metadata) trigger.Factory { return \u0026amp;MyTriggerFactory{metadata: md} } // New Creates a new trigger instance for a given id func (t *MyTriggerFactory) New(config *trigger.Config) trigger.Trigger { return \u0026amp;MyTrigger{metadata: t.metadata, config: config} } // MyTrigger is a stub for your Trigger implementation type MyTrigger struct { metadata *trigger.Metadata config *trigger.Config timers []*scheduler.Job handlers []*trigger.Handler } // Initialize implements trigger.Init.Initialize func (t *MyTrigger) Initialize(ctx trigger.InitContext) error { t.handlers = ctx.GetHandlers() return nil } // Metadata implements trigger.Trigger.Metadata func (t *MyTrigger) Metadata() *trigger.Metadata { return t.metadata } // Start implements trigger.Trigger.Start func (t *MyTrigger) Start() error { log.Debug(\u0026#34;Start\u0026#34;) handlers := t.handlers log.Debug(\u0026#34;Processing handlers\u0026#34;) for _, handler := range handlers { t.scheduleRepeating(handler) } return nil } // Stop implements trigger.Trigger.Start func (t *MyTrigger) Stop() error { // stop the trigger return nil } func (t *MyTrigger) scheduleRepeating(endpoint *trigger.Handler) { log.Info(\u0026#34;Scheduling a repeating job\u0026#34;) fn2 := func() { // Create a map to hold the trigger data triggerData := map[string]interface{}{ \u0026#34;output\u0026#34;: \u0026#34;Hello World from the new Timer Trigger\u0026#34;, } _, err := endpoint.Handle(context.Background(), triggerData) if err != nil { log.Error(\u0026#34;Error running handler: \u0026#34;, err.Error()) } } t.scheduleJobEverySecond(endpoint, fn2) } func (t *MyTrigger) scheduleJobEverySecond(tgrHandler *trigger.Handler, fn func()) { var interval int = 0 seconds, _ := strconv.Atoi(tgrHandler.GetStringSetting(\u0026#34;seconds\u0026#34;)) interval = interval + seconds log.Debug(\u0026#34;Repeating seconds: \u0026#34;, interval) // schedule repeating timerJob, err := scheduler.Every(time.Duration(interval)).Seconds().Run(fn) if err != nil { log.Error(\u0026#34;Error scheduleRepeating (repeat seconds) flo err: \u0026#34;, err.Error()) } if timerJob == nil { log.Error(\u0026#34;timerJob is nil\u0026#34;) } t.timers = append(t.timers, timerJob) } To make sure that you can test and build the new trigger, you\u0026rsquo;ll need to go get (pun intended) a few packages\ngo get github.com/TIBCOSoftware/flogo-lib/core/trigger go get github.com/TIBCOSoftware/flogo-lib/logger go get github.com/carlescere/scheduler Use your new trigger in a flow Now the only thing left to do is use the trigger inside a Flogo app! You have two options, install the new trigger using the Flogo CLI or via the Web UI. In any case you\u0026rsquo;ll first want to publish your trigger to a Git repo (the same one you\u0026rsquo;ve used in the ref field in the trigger.json). To add the new trigger to a Flogo engine and use it in a flow you can import it using the following flogo CLI command, from your flow app directory):\nflogo install github.com/yourusername/yourrepository or import it using the \u0026ldquo;Install new trigger\u0026rdquo; option in the Flogo Web UI, where you\u0026rsquo;ll need to provide the URL https://github.com/yourusername/yourrepository.\n"
},
{
	"uri": "https://tibcosoftware.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://tibcosoftware.github.io/labs/cheesecake-service/",
	"title": "Cheesecake Service",
	"tags": [],
	"description": "",
	"content": "Project Flogo offers multiple ways to build apps:\nWeb UI: You can develop flows using a zero code Web UI, which allows you to graphically build your microservices; JSON DSL: You can also build an app using a sophisticated, but elegant, JSON DSL (the Web UI uses this internally as well!); Go API: You can use the Go API to use Flogo as a Librry in your Go app! In this tutorial you will learn how to use Flogo as a Library and to build a Go app while leveraging the Flogo engine. The tutorial makes use of the REST trigger as well as the Log activity.\nWhat you\u0026rsquo;ll need Go This demo makes use of Go. If you haven\u0026rsquo;t installed Go yet, check out how to install it here. You\u0026rsquo;ll need Go 1.9.x or higher for this tutorial.\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\nThe project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations. Step 1: Outline The service you\u0026rsquo;ll build needs a file in which to code. The steps will walk you through the creation of the file and walk through the entire source code, to make sure you add all the right things you need for the cheesecake servuce. To get started, create a file called main.go, which will be the main file of the cheesecake service.\ntouch main.go A Go app that uses Flogo as a Library isn\u0026rsquo;t any different from a regular Go app, with one subtle addition right at the beginning of the file. Since the Flogo engine requires metadata of each activity you\u0026rsquo;ll need to make sure that the Go compiler creates, and packages, that metadata as well. To do so, add the below line as the first line in your file\n//go:generate go run $GOPATH/src/github.com/TIBCOSoftware/flogo-lib/flogo/gen/gen.go $GOPATH This line will tell go what to do when running the generate command. The generate command runs commands described by directives within existing files. Those commands can run any process but the intent is to create or update Go source files and in this case it generates the metadata files for your service.\nStep 2: Imports To make the app work, you\u0026rsquo;ll need a few imports\npackage main import ( // Default Go packages \u0026#34;context\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; // The Flogo Log activity \u0026#34;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026#34; // The Flogo REST trigger \u0026#34;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026#34; // Core packages for the Flogo engine \u0026#34;github.com/TIBCOSoftware/flogo-lib/core/data\u0026#34; \u0026#34;github.com/TIBCOSoftware/flogo-lib/engine\u0026#34; \u0026#34;github.com/TIBCOSoftware/flogo-lib/flogo\u0026#34; \u0026#34;github.com/TIBCOSoftware/flogo-lib/logger\u0026#34; ) Just like with any Go package, the Go compiler needs to have access to them to be able to compile the program into an executable. To make sure the packages are available, you\u0026rsquo;ll need to run\ngo get -u github.com/TIBCOSoftware/flogo-contrib/activity/log go get -u github.com/TIBCOSoftware/flogo-contrib/trigger/rest go get -u github.com/TIBCOSoftware/flogo-lib/core/data go get -u github.com/TIBCOSoftware/flogo-lib/engine go get -u github.com/TIBCOSoftware/flogo-lib/flogo go get -u github.com/TIBCOSoftware/flogo-lib/logger Step 3: Variables Hard coding variables is never a good idea. As you\u0026rsquo;re building an app that uses the HTTP trigger, you\u0026rsquo;ll want to make sure that the HTTP port is configurable. To do so add the below directive to your main.go file\nvar ( httpport = os.Getenv(\u0026#34;HTTPPORT\u0026#34;) ) The app will now be able to use an environment variable called HTTPPORT as the port for the HTTP trigger\nStep 4: Main Every app needs a main function as the entry point into the program, and a Flogo app isn\u0026rsquo;t any different. The main function in the case of a Go app that uses Flogo as a Library, might look a little different:\nfunc main() { // Create a new Flogo app app := appBuilder() e, err := flogo.NewEngine(app) if err != nil { logger.Error(err) return } engine.RunEngine(e) } The first line creates the app (using a method you\u0026rsquo;ll define in the next step). The lines after that create the Flogo engine and instruct the engine to run the app.\nStep 5: The app The Flogo engine needs an app to run, and to construct that app you\u0026rsquo;ll need another method\nfunc appBuilder() *flogo.App { app := flogo.NewApp() // Convert the HTTPPort to an integer port, err := strconv.Atoi(httpport) if err != nil { logger.Error(err) } // Register the HTTP trigger trg := app.NewTrigger(\u0026amp;rest.RestTrigger{}, map[string]interface{}{\u0026#34;port\u0026#34;: port}) trg.NewFuncHandler(map[string]interface{}{\u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/cheesecake/:name\u0026#34;}, Handler) return app } The first line constructs the app, that will be returned as the result of this method. The next step is to convert the HTTPPORT variable from a string into an integer. The last part, before the return, is creating the HTTP trigger. In this section you create a new trigger using a method call with two parameters:\nThe trigger type: \u0026amp;rest.RestTrigger{} The settings: map[string]interface{}{\u0026quot;port\u0026quot;: port} (if you check the trigger.json, you\u0026rsquo;ll see the port field is a global setting) After that, you\u0026rsquo;ll need to register a function handler for each of the HTTP methods and PATHs you want to handle. In this case the app will handle a GET operation for the path /cheesecake/:name (where :name is a PATH parameter) and as events come in for this path, it will dispatch them to a method called Handler.\nStep 6: The Handler The next step is that your app needs to handle the events and to do so, you\u0026rsquo;ll need to create a method called Handler:\n// Handler is the function that gets executed when the engine receives a message func Handler(ctx context.Context, inputs map[string]*data.Attribute) (map[string]*data.Attribute, error) { // Get the name from the path name := inputs[\u0026#34;pathParams\u0026#34;].Value().(map[string]string)[\u0026#34;name\u0026#34;] // Log, using the Flogo log activity // There are definitely better ways to do this with Go, but we want to show how to use activities in := map[string]interface{}{\u0026#34;message\u0026#34;: name, \u0026#34;flowInfo\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;addToFlow\u0026#34;: \u0026#34;true\u0026#34;} _, err := flogo.EvalActivity(\u0026amp;log.LogActivity{}, in) if err != nil { return nil, err } // Set the result message var cheesecake string switch name { case \u0026#34;retgits\u0026#34;: cheesecake = \u0026#34;Likes all cheesecakes\u0026#34; case \u0026#34;flynn\u0026#34;: cheesecake = \u0026#34;Prefers some nectar!\u0026#34; default: cheesecake = \u0026#34;Plain cheesecake is the best\u0026#34; } // The return message is a map[string]*data.Attribute which we\u0026#39;ll have to construct response := make(map[string]interface{}) response[\u0026#34;name\u0026#34;] = name response[\u0026#34;cheesecake\u0026#34;] = cheesecake ret := make(map[string]*data.Attribute) ret[\u0026#34;code\u0026#34;], _ = data.NewAttribute(\u0026#34;code\u0026#34;, data.TypeInteger, 200) ret[\u0026#34;data\u0026#34;], _ = data.NewAttribute(\u0026#34;data\u0026#34;, data.TypeAny, response) return ret, nil } From top to bottom the code does the following:\nGet the name from the PATH parameter; Execute the log activity (the inputs passed in as a map[string]interface{} are the same fields as in the activity.json); Use a regular Go switch statement to determine the favorite cheesecake based on the name; Create a map[string]interface{} with the return values of the app; Return an HTTP statuscode and the message. Step 7: Complete app Right now, your complete app should look like\n//go:generate go run $GOPATH/src/github.com/TIBCOSoftware/flogo-lib/flogo/gen/gen.go $GOPATH package main import ( // Default Go packages \u0026#34;context\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; // The Flogo Log activity \u0026#34;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026#34; // The Flogo REST trigger \u0026#34;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026#34; // Core packages for the Flogo engine \u0026#34;github.com/TIBCOSoftware/flogo-lib/core/data\u0026#34; \u0026#34;github.com/TIBCOSoftware/flogo-lib/engine\u0026#34; \u0026#34;github.com/TIBCOSoftware/flogo-lib/flogo\u0026#34; \u0026#34;github.com/TIBCOSoftware/flogo-lib/logger\u0026#34; ) var ( httpport = os.Getenv(\u0026#34;HTTPPORT\u0026#34;) ) func main() { // Create a new Flogo app app := appBuilder() e, err := flogo.NewEngine(app) if err != nil { logger.Error(err) return } engine.RunEngine(e) } func appBuilder() *flogo.App { app := flogo.NewApp() // Convert the HTTPPort to an integer port, err := strconv.Atoi(httpport) if err != nil { logger.Error(err) } // Register the HTTP trigger trg := app.NewTrigger(\u0026amp;rest.RestTrigger{}, map[string]interface{}{\u0026#34;port\u0026#34;: port}) trg.NewFuncHandler(map[string]interface{}{\u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/cheesecake/:name\u0026#34;}, Handler) return app } // Handler is the function that gets executed when the engine receives a message func Handler(ctx context.Context, inputs map[string]*data.Attribute) (map[string]*data.Attribute, error) { // Get the name from the path name := inputs[\u0026#34;pathParams\u0026#34;].Value().(map[string]string)[\u0026#34;name\u0026#34;] // Log, using the Flogo log activity // There are definitely better ways to do this with Go, but we want to show how to use activities in := map[string]interface{}{\u0026#34;message\u0026#34;: name, \u0026#34;flowInfo\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;addToFlow\u0026#34;: \u0026#34;true\u0026#34;} _, err := flogo.EvalActivity(\u0026amp;log.LogActivity{}, in) if err != nil { return nil, err } // Set the result message var cheesecake string switch name { case \u0026#34;retgits\u0026#34;: cheesecake = \u0026#34;Likes all cheesecakes\u0026#34; case \u0026#34;flynn\u0026#34;: cheesecake = \u0026#34;Prefers some nectar!\u0026#34; default: cheesecake = \u0026#34;Plain cheesecake is the best\u0026#34; } // The return message is a map[string]*data.Attribute which we\u0026#39;ll have to construct response := make(map[string]interface{}) response[\u0026#34;name\u0026#34;] = name response[\u0026#34;cheesecake\u0026#34;] = cheesecake ret := make(map[string]*data.Attribute) ret[\u0026#34;code\u0026#34;], _ = data.NewAttribute(\u0026#34;code\u0026#34;, data.TypeInteger, 200) ret[\u0026#34;data\u0026#34;], _ = data.NewAttribute(\u0026#34;data\u0026#34;, data.TypeAny, response) return ret, nil } Step 7: Build To build the app, you\u0026rsquo;ll need to run two commands:\n// Make sure that the metadata is generated go generate // Build the app go build -o cheesecakesvc Because you\u0026rsquo;re using Flogo as a Library in your app, you don\u0026rsquo;t need to use the flogo build command but instead use the regular go build with any parameters you might want to pass in (-o cheesecakesvc means the output will be an executable called cheesecakesvc).\nStep 8: Run To run the app simply run\nHTTPPORT=8888 ./cheesecakesvc And in a separate terminal run to see the result of your app\n$ curl --request GET --url http://localhost:8888/cheesecake/retgits {\u0026#34;cheesecake\u0026#34;:\u0026#34;Likes all cheesecakes\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;retgits\u0026#34;} "
},
{
	"uri": "https://tibcosoftware.github.io/labs/cloudfoundry/",
	"title": "Cloud Deployments: Cloud Foundry",
	"tags": [],
	"description": "",
	"content": "Cloud Foundry is an open-source platform as a service (PaaS) that provides you with a choice of clouds, developer frameworks, and application services.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nCloud Foundry If you want to run Flogo apps in a Cloud Foundry environment, you have two options:\nUsing the binary buildpack Using docker containers If you want to try out Pivotal Cloud Foundry, you might to check out PCF Dev and follow the first three steps to get your environment up and running.\nUsing the binary buildpack With the Cloud Foundry Binary Buildpack you can run arbitrary binary web servers on Cloud Foundry without the need to have a specific build pack for that language. Since Flogo can compile down to a binary, this saves you from installing additional buildpacks. There are a few prerequisites you need to take into account though:\nYou\u0026rsquo;ll need a binary that is able to run on the same OS as CF is deployed (most likely Linux, which you can do with env GOOS=linux flogo build) You\u0026rsquo;ll need to make sure you\u0026rsquo;re using port 8080 for your Receive HTTP Message trigger Steps to deploy:\nMake sure the app is executable: chmod +x \u0026lt;appname\u0026gt; Push to PCF: cf push \u0026lt;name in pcf\u0026gt; -c './\u0026lt;appname\u0026gt;' -b binary_buildpack For more detailed information and more flags you can set during deployments, check Binary Buildpack in the Cloud Foundry docs.\nUsing docker By default, apps deployed with the cf push command run in standard Cloud Foundry Linux containers. With Docker support enabled, Cloud Foundry can also deploy and manage apps running in Docker containers.\nTo enable docker support an administrator has to run:\ncf enable-feature-flag diego_docker For example, the below command would push and run the Project Flogo Web UI on Cloud Foundry\ncf push my-app --docker-image flogo/flogo-docker For more detailed information and more flags you can set during deployments, check Deploy an App with Docker in the Cloud Foundry docs.\n"
},
{
	"uri": "https://tibcosoftware.github.io/labs/docker/",
	"title": "Cloud Deployments: Docker",
	"tags": [],
	"description": "",
	"content": "Flogo apps are ultralight so building docker images is not only really easy, because it can embed all dependencies it can also run inside of super small docker containers.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nUsing flogo Out of the box, Flogo has the option to build a docker container from the app.\nflogo build -e -docker \u0026lt;trigger id\u0026gt; The above command will build a Flogo app, with embedded configuration (-e), and create a docker image where it can expose the PORT based on which trigger ID you specify. If you don\u0026rsquo;t want to expose a port (for example, because you start with a timer) you can specify no-trigger as the trigger id.\nThe docker file it generates and uses to build the docker image is:\n# Dockerfile for {{.name}} # VERSION {{.version}} FROM alpine RUN apk update \u0026amp;\u0026amp; apk add ca-certificates ADD {{.name}}-linux-amd64 . EXPOSE {{.port}} CMD ./{{.name}}-linux-amd64` note that {{.name}} and {{.port}} are substitution variables coming from the configuration of your app\nAfter building the image you can run the container using the docker run command\nDo-It-Yourself While practical, you don\u0026rsquo;t have to rely on flogo to generate the docker image for you. If you prefer to construct the Dockerfile yourself, that is perfectly okay too. The flogo cli simply wraps the command:\ndocker build . -t \u0026lt;app name\u0026gt;:\u0026lt;app version\u0026gt; "
},
{
	"uri": "https://tibcosoftware.github.io/labs/cicd-for-activities/",
	"title": "Continuously testing Flogo activities",
	"tags": [],
	"description": "",
	"content": "Depending on where you store the source code and how publicly you want to have the code available you have a few options to continuously testing Flogo activities. In this tutorial you\u0026rsquo;ll look at Jenkins when using a local git server and Travis-CI for activities on GitHub\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nJenkins \u0026amp; Travis-CI You\u0026rsquo;ll need to have Jenkins set up, together with the Go plugin (Go version 1.10 or higher) and you\u0026rsquo;ll need an account to Travis-CI. An account for the latter is free, if you want to use it with Open Source repositories.\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\nThe project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations. Structure The project structure we\u0026rsquo;ll use has separate folders for activities and triggers. A sample layout would look like this:\n├───\u0026lt;Repo root\u0026gt; │ └───activity | | └───\u0026lt;my-activity\u0026gt; | | |───\u0026lt;all my files\u0026gt; │ └───trigger | └───\u0026lt;my-trigger\u0026gt; | |───\u0026lt;all my files\u0026gt; For example, the Flogo Contrib repository looks like:\n├─── flogo-contrib │ └───a ctivity | └─── log | |─── README.md | |─── activity.go | |─── activity.json | |─── activity_test.go Jenkins Installing the Go Plugin To get started with Go in Jenkins there is a great plugin that makes it all very easy. To install the Go Plugin for Jenkins go to Manage Jenkins -\u0026gt; Manage Plugins and search for Go Plugin on the Available tab. After that select Download now and install after restart to restart Jenkins.\nAfter you\u0026rsquo;ve done that, it is time to select the version of Go you want to use for the builds. Go to Manage Jenkins -\u0026gt; Global Tool Configuration and look for the Go section. Click on the button Go installations\u0026hellip; and specify a name for your installation. The name itself doesn\u0026rsquo;t have any significance, but it will make it a lot easier to find the right one later on. Check the box for Install automatically and select the version you want to have installed. After that click Apply follows by Save.\nConfiguring the build job Within Jenkins create a New Item and select a Freestyle project. Since repositories can have multiple activities, you can select a parameterized project.\nIn the Build Environment section you need to check two boxes:\nDelete workspace before build starts: This makes sure you always start with fresh code and nothing lingers around; Set up Go programming language tools: This was added by the Go Plugin and lets you pick the Go version you configured earlier (this is where the name comes in). In the Build section add a new build step that executes a shell command. The shell command will take care of getting the dependencies and executing the test cases:\n## Go get the Project Flogo dependencies go get github.com/TIBCOSoftware/flogo-lib/... go get github.com/TIBCOSoftware/flogo-contrib/... ## Go get the test dependencies go get github.com/stretchr/testify/assert ## Find all the activities and run the test cases for them for path in ./activity/*; do [ -d \u0026#34;${path}\u0026#34; ] || continue # if not a directory, skip dirname=\u0026#34;$(basename \u0026#34;${path}\u0026#34;)\u0026#34; ## Run the test cases go test ./activity/$dirname done Travis-CI For code that exists on GitHub there are a lot of options (including Jenkins), but let\u0026rsquo;s look at Travis-CI. Travis-CI is continuous integration for projects hosted on GitHub and provides automation for testing building and deploying. They have quite a good Getting Started guide, so this tutorial skips that part of the setup and dives right into it.\nAs you push your code to GitHub, the only additional file you need for Travis-CI to work is a file called .travis.yml (and you\u0026rsquo;ll need to turn on the builds from the Travis Web UI).\n## We don\u0026#39;t need elevated privileges sudo: false ## The language should be Go and we\u0026#39;ll use version 1.8.3 language: go go: - 1.10 ## The below statement skips all branches that start with a \u0026#39;v\u0026#39; (e.g. v1) so that we can have working branches that get committed. branches: except: - /^v.*/ ## Install the dependencies we need install: - go get github.com/TIBCOSoftware/flogo-lib/... - go get github.com/TIBCOSoftware/flogo-contrib/... - go get github.com/stretchr/testify/assert ## The script is the same as it was in Jenkins, though joined to be a single line script: - for path in ./activity/*; do [ -d \u0026#34;${path}\u0026#34; ] || continue; dirname=\u0026#34;$(basename \u0026#34;${path}\u0026#34;)\u0026#34;; go test ./activity/$dirname; done; zip -r release.zip ./activity/ ./connector/ "
},
{
	"uri": "https://tibcosoftware.github.io/labs/flogo-and-sam/",
	"title": "Flogo and SAM",
	"tags": [],
	"description": "",
	"content": "The AWS Serverless Application Model (AWS SAM) helps you to define serverless applications in simple and clean syntax. You can use the SAM CLI to manage Serverless applications written with AWS Serverless Application Model (SAM). SAM CLI can be used to test functions locally, start a local API Gateway from a SAM template, validate a SAM template, fetch logs, generate sample payloads for various event sources, and generate a SAM project in your favorite Lambda Runtime.\nIn this tutorial you\u0026rsquo;ll use the AWS SAM CLI to test a Flogo app that has a Lambda trigger, without deploying it to AWS Lambda. This will obviously increase the developer productivity even more!\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nAWS SAM CLI The demo makes use of the AWS SAM CLI. If you haven\u0026rsquo;t installed it yet, please check out the installation instructions for your OS.\nDocker The AWS SAM CLI makes use of Docker images to run your app locally. You need to have Docker installed and running on your machine to complete this tutorial.\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\nThe project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations. Step 1: Building the app For this tutorial, you can make use of any app that uses the Lambda trigger. If you don\u0026rsquo;t have an app yet, you can use this one:\nThe Flogo app has a Lambda trigger and a PATH parameter called name.\n{ \u0026#34;name\u0026#34;: \u0026#34;Tutorial\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;flogo:app\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;appModel\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;triggers\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;start_flow_as_a_function_in_lambda\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/trigger/lambda\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Start Flow as a function in Lambda\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Simple Lambda Trigger\u0026#34;, \u0026#34;settings\u0026#34;: {}, \u0026#34;handlers\u0026#34;: [ { \u0026#34;action\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/action/flow\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;flowURI\u0026#34;: \u0026#34;res://flow:lambda_flow\u0026#34; }, \u0026#34;mappings\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;mapTo\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;assign\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$.evt.name\u0026#34; } ], \u0026#34;output\u0026#34;: [ { \u0026#34;mapTo\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;assign\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$.greeting\u0026#34; } ] } } } ] } ], \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;flow:lambda_flow\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;LambdaFlow\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;output\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;greeting\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;any\u0026#34; } ] }, \u0026#34;tasks\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;log_2\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Log Message\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Simple Log Activity\u0026#34;, \u0026#34;activity\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026#34;, \u0026#34;input\u0026#34;: { \u0026#34;message\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;flowInfo\u0026#34;: \u0026#34;false\u0026#34;, \u0026#34;addToFlow\u0026#34;: \u0026#34;false\u0026#34; }, \u0026#34;mappings\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;expression\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;string.concat(\\\u0026#34;Hello \\\u0026#34;, $flow.name)\u0026#34;, \u0026#34;mapTo\u0026#34;: \u0026#34;message\u0026#34; } ] } } }, { \u0026#34;id\u0026#34;: \u0026#34;actreturn_3\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Return\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Simple Return Activity\u0026#34;, \u0026#34;activity\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/activity/actreturn\u0026#34;, \u0026#34;input\u0026#34;: { \u0026#34;mappings\u0026#34;: [ { \u0026#34;mapTo\u0026#34;: \u0026#34;greeting\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;value\u0026#34;: {\u0026#34;Hello\u0026#34;: \u0026#34;{{$flow.name}}\u0026#34;} } ] } } } ], \u0026#34;links\u0026#34;: [ { \u0026#34;from\u0026#34;: \u0026#34;log_2\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;actreturn_3\u0026#34; } ] } } ] } To create a Lambda file from this, you can run:\n// Create the app flogo create -f flogo.json myapp // Build the app cd myapp flogo build -e -shim start_flow_as_a_function_in_lambda Step 2: Create a template.yml You can use the sam local invoke command to manually test your code by running Lambda function locally. With SAM CLI, you can easily author automated integration tests by first running tests against local Lambda functions before deploying to the cloud.\nNow that is awesome! In order to make that work, SAM needs to have a descriptor called template.yml that describes what the function is and what other parameters it has. Assuming you\u0026rsquo;ve used the app above, a YAML file could look like\nAWSTemplateFormatVersion: \u0026#39;2010-09-09\u0026#39; Transform: \u0026#39;AWS::Serverless-2016-10-31\u0026#39; Description: Serverless Application Model Resources: flogoapp: # The name you want to give your Lambda function Type: \u0026#39;AWS::Serverless::Function\u0026#39; Properties: CodeUri: bin/ # The location where to find the executable file (not the zip file from the Web UI) Handler: handler # The name of the handler generated by the flogo build command Runtime: go1.x Tracing: Active Timeout: 120 Events: flogoevent: # This is a sample event Type: Schedule Properties: Schedule: cron(0 2 * * ? *) # Run at 2:00 am (UTC) every day Description: Run Hello World every night! # A description for your Lambda app MemorySize: 128 # The amount of memory you want to give your app in Lambda For clarity sake, you can create a new directory called lambda and put all files in that directory.\nStep 3: Events To be able to test the apps locally, SAM makes use of events from JSON files. Events describe the input that would normally come from external apps like Amazon S3 or Amazon API Gateway. In this case, the event will be really simple. You\u0026rsquo;ll have to create a new file called event.json and the content of the file will be:\n{ \u0026#34;name\u0026#34;: \u0026#34;World\u0026#34; } Step 4: Run locally Before you can run the app, the final step is to copy the executable file (generated in step 1) to the right location. Create a bin folder in the lambda folder you created earlier and copy the file /src/myapp/handler to that location.\nFrom a terminal window you can now use the SAM CLI to run your app locally:\nsam local invoke \u0026lt;function\u0026gt; -e \u0026lt;event.json file\u0026gt; So in this case the command will be\nsam local invoke flogoapp -e event.json As you run that, the output will look like (the last line will display the result of your app)\n2018-10-03 16:53:03 Invoking handler (go1.x) 2018-10-03 16:53:03 Found credentials in shared credentials file: ~/.aws/credentials Fetching lambci/lambda:go1.x Docker container image...... 2018-10-03 16:53:04 Mounting /Users/lstigter/Downloads/myapp/lambda/bin as /var/task:ro inside runtime container START RequestId: 8791ddd9-c612-1864-f381-75d1506ad692 Version: $LATEST 2018-10-03 23:53:05.119 INFO [trigger-flogo-lambda] - Starting AWS Lambda Trigger 2018/10/03 23:53:05 Starting AWS Lambda Trigger 2018/10/03 23:53:05 Received evt: \u0026#39;map[name:World]\u0026#39; 2018/10/03 23:53:05 Received ctx: \u0026#39;map[awsRequestId:8791ddd9-c612-1864-f381-75d1506ad692 functionName:test functionVersion:$LATEST logGroupName:/aws/lambda/test logStreamName:2018/10/03/[$LATEST]b1ff97369e34dbbe4f8ee4f578cde273 memoryLimitInMB:128]\u0026#39; 2018-10-03 23:53:05.123 INFO [activity-flogo-log] - Hello World END RequestId: 8791ddd9-c612-1864-f381-75d1506ad692 REPORT RequestId: 8791ddd9-c612-1864-f381-75d1506ad692\tDuration: 5.38 ms\tBilled Duration: 100 ms\tMemory Size: 128 MB\tMax Memory Used: 8 MB {\u0026#34;Hello\u0026#34;:\u0026#34;World\u0026#34;} "
},
{
	"uri": "https://tibcosoftware.github.io/labs/invoiceservice/",
	"title": "Invoice Service",
	"tags": [],
	"description": "",
	"content": "Let\u0026rsquo;s build an invoiceservice! In this tutorial we\u0026rsquo;ll walk you through building an app with several community-driven activities and talks to other services as well. The lab also covers Input/Output mappings, Invoking a REST service and Complex object mapping.\nWhat you\u0026rsquo;ll need The Flogo Web UI This demo makes use of the Flogo Web UI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo Web UI\nApps This demo builds one of the services of the Kubernetes tutorial. After building this app, you might want to try and deploy it to Kubernetes too! The app will use the Payment Service to get some data, so you\u0026rsquo;ll likely want to start with that one if you haven\u0026rsquo;t built it yet.\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\nThe project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations. Step 1: Create the app Open the Flogo Web UI and from there, click \u0026ldquo;New\u0026rdquo; to create a new microservice and give your new app a name. Click \u0026ldquo;Create a Flow\u0026rdquo; to create a new flow and give it any name that you want. Now click on the flow you just created and to open the canvas where you can design your flow.\nStep 2: Add a trigger Triggers are used to signal a flow to run. In this case you want to receive an HTTP message to get invoice information. To add a trigger, click on the \u0026ldquo;+\u0026rdquo; icon on the left hand side of the screen and select the Receive HTTP Message trigger.\nThe invoice ID for which you want the information comes from the HTTP request. To get that parameter into the flow, you\u0026rsquo;ll need to create an Input parameter which you can do by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen. For example, you can call the parameter \u0026ldquo;id\u0026rdquo;, keep the type as \u0026ldquo;string\u0026rdquo; and click save.\nThe response to the HTTP request will be a message and the HTTP status code, and to be able to send data back you\u0026rsquo;ll need to have Output parameters. You can create them by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen. From there, select Output and configure two parameters:\nParameter name: code Type: integer Now click on the + sign to add a new parameter\nParameter name: response Type: any Now it is time to configure the trigger to listen to HTTP messages. To start, click on the trigger and a new dialog will open with a bunch of options. In this dialog you\u0026rsquo;ll have to provide:\nPort: The port on which your app will listen (set this to 9234) Method: The HTTP method that will trigger this flow (set this to GET) Path: The path that will route the messages to this flow (set this to /api/invoices/:id, the :id means that you can use that as a path parameter in your mappings) After that, click on \u0026ldquo;Map to flow inputs\u0026rdquo; to map the invoiceId from the HTTP trigger to the \u0026ldquo;id\u0026rdquo; parameter we created earlier. The parameter will already be selected because it is the only one. Since the data will come from the PATH parameters, you\u0026rsquo;ll need to type $.pathParams.id in the input box, which means the Flogo app will expect a PATH parameter called invoiceId to be present.\nWith the inputs taken care off, let\u0026rsquo;s look at the outputs. Click on \u0026ldquo;Map to flow outputs\u0026rdquo; to map the output parameters you created earlier to the response of the trigger. The code parameter will already be selected, so click on \u0026ldquo;123 code\u0026rdquo; in the Flow Output section to create the mapping. Now click on \u0026ldquo;response\u0026rdquo; in the Trigger Response section and select \u0026ldquo;* data\u0026rdquo; from the Flow Output section to create the mapping. Click \u0026ldquo;save\u0026rdquo; to make sure everything is, well…, saved. You can click the little X on the top-right (no, not your browser…) to close the dialog window and go back to the flow.\nThe URL on which our microservice will listen will be http://localhost:9234/api/invoices/:id (the :invoiceId is a parameter that you can replace with anything during runtime). If you made changes to any of the variables above, please make sure to change those in the rest of these examples.\nStep 3: Add activities You’ll have to add some activities to the flow for it to do something. To add an activity click on the large + sign\nA list with all the activities the Flogo Web UI knows about will appear. From the list you can pick the \u0026ldquo;Log Message\u0026rdquo; activity (or use the searchbar to find it) and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Log Message\u0026rdquo; activity. Click on \u0026ldquo;a.. message\u0026rdquo; and type string.concat(\u0026quot;Get Invoice request received for: \u0026quot;, $flow.id) in the box (on the right hand side of the screen). This will, when you run the app, concatenate a string and the id.\nIn the same way, add a new activity. The activity that is needed, to generate a random number, isn\u0026rsquo;t part of the out-of-the-box activities so you\u0026rsquo;ll need to import it.\nClick \u0026ldquo;Install new activity\u0026rdquo; and a dialog appears where you can paste (or type) the URL of where the Flogo Web UI can get the sources. For this activity you can use https://github.com/retgits/flogo-components/activity/randomnumber. From the updated list you can pick the \u0026ldquo;Random number\u0026rdquo; activity (or use the searchbar to find it) and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Random number\u0026rdquo; activity.\nmax: 2000 (the maximum value the random number will have) min: 1000 (the minimum value the random number will have) In the same way, add a new activity and this time install the \u0026ldquo;Combine\u0026rdquo; activity to concatenate multiple values. The URL you\u0026rsquo;ll need to use to install the activity is https://github.com/jvanderl/flogo-components/activity/combine.\ndelimeter: \u0026quot;-\u0026quot; (the delimeter used to separate the strings) part1: \u0026quot;INV\u0026quot; (a hardcoded string) part2: $flow.id (the id that was passed in as a PATH parameter) Add another \u0026ldquo;Random number\u0026rdquo; activity to the flow, in the same way you\u0026rsquo;ve done before. This time you won\u0026rsquo;t need to install it, because the Flogo Web UI already knows about it. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Random number\u0026rdquo; activity.\nmax: 1000 (the maximum value the random number will have) min: 0 (the minimum value the random number will have) The next step is to add a \u0026ldquo;Invoke REST Service\u0026rdquo; activity, which will call the Payment Service to get some data. You can add the activity in the same way you\u0026rsquo;ve done before. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs:\ncontent: \u0026lt;empty\u0026gt; (the content you want to send to the REST service, in this case the service doesn\u0026rsquo;t need any so you can keep this field empty) header: \u0026lt;empty\u0026gt; (any header parameters you want to send to the REST service, in this case the service doesn\u0026rsquo;t need any so you can keep this field empty) method: \u0026quot;GET\u0026quot; (the HTTP method to call the other service) pathParams: {\u0026quot;id\u0026quot;:\u0026quot;{{$flow.id}}\u0026quot;} (this will add a PATH parameter with the value of the id that was passed into this flow) proxy: \u0026lt;empty\u0026gt; (HTTP proxy settings you need to call the other service you can keep this field empty) queryParams: \u0026lt;empty\u0026gt; (any query parameters you want to send to the REST service, in this case the service doesn\u0026rsquo;t need any so you can keep this field empty) skipSsl: \u0026quot;false\u0026quot; (This setting indicates if, when HTTPS is used, the certificate check should be skipped or not) uri: http://localhost:9233/api/expected-date/:id (This is the URL, including any PATH parameters used, to call the other service. In this case the Payment Service) Step 4: Return data To complete the flow, add a Return activity. Hover over it to see the cog and select configure to bring up the modal to configure the activity. The return activity is always the last activity in a branch and sets the values that are returned to the trigger. Click on \u0026ldquo;123 code\u0026rdquo; and type 200 in the input field to set the HTTP Response code to 200.\nNow click on \u0026ldquo;* message\u0026rdquo; and type (or copy) the structure below. Finally click \u0026ldquo;Save\u0026rdquo; to complete the mapping.\n{ \u0026#34;id\u0026#34;:\u0026#34;{{$flow.id}}\u0026#34;, \u0026#34;ref\u0026#34;:\u0026#34;{{$activity[combine_4].result}}\u0026#34;, \u0026#34;amount\u0026#34;:\u0026#34;{{$activity[randomnumber_3].result}}\u0026#34;, \u0026#34;balance\u0026#34;:\u0026#34;{{$activity[randomnumber_5].result}}\u0026#34;, \u0026#34;expectedPaymentDate\u0026#34;:\u0026#34;{{$activity[rest_6].result.expectedDate}}\u0026#34;, \u0026#34;currency\u0026#34;:\u0026#34;USD\u0026#34; } The above snippet maps the values from the REST service to fields that are sent back to the trigger. The mapping is done in a JavaScript-like syntax, so $flow.id means it will get the id that was used as an input parameter to the flow (the one you configured earlier) and the $activity[xxx].result will get the result elements from the various activities. The double curly braces are used as by Go\u0026rsquo;s templating engine.\nYour final flow should look something like the one below.\nStep 5: Build Those were all the steps needed to design the flow, now let\u0026rsquo;s build an executable from it. On the main screen of your flow click on the \u0026ldquo;\u0026lt;\u0026rdquo; button on the top-left hand side of the screen. That will bring you back to your microservice and from here you can select \u0026ldquo;Build\u0026rdquo;. Choose whichever operating system you\u0026rsquo;re running on to download the executable.\nStep 6: Run To see the results, start both apps and run curl --request GET --url http://localhost:9234/api/invoices/12345. That will give you a result like\n{\u0026#34;amount\u0026#34;:1456,\u0026#34;balance\u0026#34;:456,\u0026#34;currency\u0026#34;:\u0026#34;USD\u0026#34;,\u0026#34;expectedPaymentDate\u0026#34;:\u0026#34;2018-02-28\u0026#34;,\u0026#34;id\u0026#34;:\u0026#34;2345\u0026#34;,\u0026#34;ref\u0026#34;:\u0026#34;INV-2345\u0026#34;} "
},
{
	"uri": "https://tibcosoftware.github.io/labs/iot-howto/",
	"title": "IoT Apps",
	"tags": [],
	"description": "",
	"content": "Flogo can run almost anywhere. From the largest clouds, to the smallest of devices and everything in between. Take this lab to get yourself familiar with how to develop apps for IoT devices using the Flogo CLI.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\nThe project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations. Step 1: flogo.json Flogo apps are constructed using a JSON file called flogo.json. You can create those files using the Flogo Web UI, or you can create them manually. Now let\u0026rsquo;s create the flogo.json file. To do that, execute touch flogo.json in a terminal (or open up a new file in your text editor), which will create a new empty file for you. The app you\u0026rsquo;ll build has a REST trigger that counts the number of times it is invoked and logs that to the console.\n{ \u0026#34;name\u0026#34;: \u0026#34;IoTApp\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;flogo:app\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;appModel\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;triggers\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;receive_http_message\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Receive HTTP Message\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Simple REST Trigger\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;port\u0026#34;: 9233 }, \u0026#34;handlers\u0026#34;: [ { \u0026#34;action\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/action/flow\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;flowURI\u0026#34;: \u0026#34;res://flow:counter_flow\u0026#34; } }, \u0026#34;settings\u0026#34;: { \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/counter\u0026#34; } } ] } ], \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;flow:counter_flow\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;CounterFlow\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;counter_2\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Increment Counter\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Simple Global Counter Activity\u0026#34;, \u0026#34;activity\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/activity/counter\u0026#34;, \u0026#34;input\u0026#34;: { \u0026#34;counterName\u0026#34;: \u0026#34;number\u0026#34;, \u0026#34;increment\u0026#34;: true, \u0026#34;reset\u0026#34;: false } } }, { \u0026#34;id\u0026#34;: \u0026#34;log_3\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Log Message\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Simple Log Activity\u0026#34;, \u0026#34;activity\u0026#34;: { \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026#34;, \u0026#34;input\u0026#34;: { \u0026#34;flowInfo\u0026#34;: \u0026#34;false\u0026#34;, \u0026#34;addToFlow\u0026#34;: \u0026#34;false\u0026#34; }, \u0026#34;mappings\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;assign\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$activity[counter_2].value\u0026#34;, \u0026#34;mapTo\u0026#34;: \u0026#34;message\u0026#34; } ] } } } ], \u0026#34;links\u0026#34;: [ { \u0026#34;from\u0026#34;: \u0026#34;counter_2\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;log_3\u0026#34; } ] } } ] } Step 2: Building an app To create the source code simply execute flogo create -f flogo.json myapp. This tells the Flogo CLI to take the flogo.json file and create the source for the app in a folder called myapp. It will also download a few Go packages that the app will need.\nThe next step is to build the executable and for that we need to be in the directory myapp (cd myapp). To build a flogo app from the source you can execute the command flogo build -e, which tells the flogo cli to build the app (and place it in a bin directory) and embed all configuration into a single executable\nStep 3: Running the app You have just built the Flogo app, so now you can test it. From the bin directory (cd bin) you can run ./myapp which will start the app. In the terminal you\u0026rsquo;ll see something like\n2018-05-12 04:34:56.434 INFO [engine] - Engine Starting... 2018-05-12 04:34:56.435 INFO [engine] - Starting Services... 2018-05-12 04:34:56.435 INFO [engine] - Started Services 2018-05-12 04:34:56.435 INFO [engine] - Starting Triggers... 2018-05-12 04:34:56.435 INFO [engine] - Trigger [ receive_http_message ]: Started 2018-05-12 04:34:56.435 INFO [engine] - Triggers Started 2018-05-12 04:34:56.435 INFO [engine] - Engine Started To test it we\u0026rsquo;ll use the curl command line tool, which is installed on most Operating Systems. From a new terminal window execute the command curl http://localhost:9233/counter. It will send an HTTP request to the app on port 9233 (which was configured in the flogo.json file) and it will log the number of invocations.\nStep 4: Getting it to your device Once you are ready to test your application on your device, check out these specialized labs that talk about building Flogo apps specifically for that device.\nRaspberry Pi Intel Edison BeagleBone "
},
{
	"uri": "https://tibcosoftware.github.io/labs/beaglebone-iot/",
	"title": "IoT Apps: BeagleBone",
	"tags": [],
	"description": "",
	"content": "Flogo can run almost anywhere. From the largest clouds, to the smallest of devices and everything in between. Take this lab to get yourself familiar with how to develop apps for IoT devices using the Flogo CLI. Let\u0026rsquo;s look at building for BeagleBone!\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nIoT How-to This demo makes use of the IoT Apps tutorial. If you haven\u0026rsquo;t done that one yet, this is a great time to do so!\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\nThe project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations. Building an app To build a Flogo application for BeagleBone, you simply use the build command with the appropriate enviroment variables set to compile to Go code for an ARM processor.\nOn macOS or Linux machines the additional parameters you need to set when building Flogo apps are:\nenv GOARM=7 GOARCH=arm GOOS=linux flogo build -e On Windows the additional parameters you need to set when building Flogo apps are:\nSET GOARM=7 SET GOARCH=arm SET GOOS=linux flogo build -e Note that the above samples compile for an ARMv6 processor. You can check the BeagleBone website to see which version of the ARM processor you have.\n"
},
{
	"uri": "https://tibcosoftware.github.io/labs/edison-iot/",
	"title": "IoT Apps: Intel Edison",
	"tags": [],
	"description": "",
	"content": "Flogo can run almost anywhere. From the largest clouds, to the smallest of devices and everything in between. Take this lab to get yourself familiar with how to develop apps for IoT devices using the Flogo CLI. Let\u0026rsquo;s look at building for Intel Edison!\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nIoT How-to This demo makes use of the IoT Apps tutorial. If you haven\u0026rsquo;t done that one yet, this is a great time to do so!\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\nThe project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations. Building an app To build a Flogo application for BeagleBone, you simply use the build command with the appropriate enviroment variables set to compile to Go code for an 386 architecture processor.\nOn macOS or Linux machines the additional parameters you need to set when building Flogo apps are:\nenv GOARCH=386 GOOS=linux flogo build -e On Windows the additional parameters you need to set when building Flogo apps are:\nSET GOARCH=386 SET GOOS=linux flogo build -e "
},
{
	"uri": "https://tibcosoftware.github.io/labs/raspberry-iot-cli/",
	"title": "IoT Apps: Raspberry Pi",
	"tags": [],
	"description": "",
	"content": "Flogo can run almost anywhere. From the largest clouds, to the smallest of devices and everything in between. Take this lab to get yourself familiar with how to develop apps for IoT devices using the Flogo CLI. Let\u0026rsquo;s look at building for Raspberry Pi!\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nIoT How-to This demo makes use of the IoT Apps tutorial. If you haven\u0026rsquo;t done that one yet, this is a great time to do so!\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\nThe project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations. Building an app To build a Flogo application for Raspberry Pi, you simply use the build command with the appropriate enviroment variables set to compile to Go code for an ARM processor.\nOn macOS or Linux machines the additional parameters you need to set when building Flogo apps are:\nenv GOARM=6 GOARCH=arm GOOS=linux flogo build -e On Windows the additional parameters you need to set when building Flogo apps are:\nSET GOARM=6 SET GOARCH=arm SET GOOS=linux flogo build -e Note that the above samples compile for an ARMv6 processor. You can check the Raspberry Pi website to see which version of the ARM processor you have.\n"
},
{
	"uri": "https://tibcosoftware.github.io/labs/kubernetes/",
	"title": "Kubernetes",
	"tags": [],
	"description": "",
	"content": "Kubernetes is probably the most wellknown container orchestration platform out there, with a ton of companies building and hosting their own specific version or making use of of one. In this demo you explore how to run Flogo apps on Kubernetes. The demo will walk you through deploying two apps:\nAn invoice service which gets details on the invoice you specify in the URL A payment service which gets details on the expected payment date for the invoice (The invoice service will make use of the payment service to display all data) What you\u0026rsquo;ll need The demo needs a working Kubernetes cluster. If you haven\u0026rsquo;t got one, setting one up using minikube is quite easy! You\u0026rsquo;ll also need to have the Flogo CLI installed. If that is not the case, you might want to install them first. Our Getting Started guide walks you through the installation of Go, the Flogo CLI and Go Dep.\nScripts A fully scripted version of this tutorial is available in the samples directory as well! There are two different scenarios to deploy, one makes use of apps built using the Flogo Web UI and the other makes use of apps with the same functionality but built using the Go API.\nThe apps built with the Flogo Web UI are:\nInvoice Service Payment Service The apps built with the Go API are:\nInvoice Service - Go Payment Service - Go The shell script will allow you to choose between them, in this walk through you\u0026rsquo;ll make use of the apps built with the Flogo Web UI. In the scenario you\u0026rsquo;ll find a bunch of code blocks from which you can copy the code directly to your terminal. Please note that these commands are for MacOS and Linux, but should work on most Windows based systems as well.\nGetting the artifacts The first step is to create a directory that will contain all the artifacts. For now we\u0026rsquo;ll call that one flogo-on-kubernetes\n# Set a root directory so that all commands start from the same directory ROOTDIR=`pwd` # Set a working directory for all the artifacts WORKDIR=flogo-on-kubernetes # Make sure the directory is cleanly created rm -rf $ROOTDIR/$WORKDIR mkdir -p $ROOTDIR/$WORKDIR Getting the Flogo apps The demo will consist of two apps deployed to a Kubernetes cluster. We\u0026rsquo;ll use docker images that already exist, but we do want to provide you with all the code and artifacts to show the apps in the Flogo Web UI. Let\u0026rsquo;s start with downloading the apps\ncd $ROOTDIR/$WORKDIR curl -o invoiceservice.json https://raw.githubusercontent.com/retgits/flogo-components/master/apps/invoiceservice/invoiceservice.json curl -o paymentservice.json https://raw.githubusercontent.com/retgits/flogo-components/master/apps/paymentservice/paymentservice.json For each of the apps we\u0026rsquo;ll need to run a command to create the app structure and download any dependencies\nflogo create -f invoiceservice.json invoiceservice flogo create -f paymentservice.json paymentservice Creating executables Now, let\u0026rsquo;s build the executables for the first app. We\u0026rsquo;ll build two executables. One that will be able to run natively on your machine and one that will be a Linux executable to run in a docker container. So for the first app those commands are\ncd $ROOTDIR/$WORKDIR/invoiceservice env GOOS=linux flogo build -e flogo build -e For the second app they are\ncd $ROOTDIR/$WORKDIR/paymentservice env GOOS=linux flogo build -e flogo build -e Dockerize all the things Now on to Docker! We\u0026rsquo;ll create docker images based on Alpine Linux. We\u0026rsquo;ll put a Dockerfile in the bin/linux_amd64 folder and run the command\n# Set your Docker Hub username DOCKERHUBUSER=my-name # Go to the right directory cd $ROOTDIR/$WORKDIR/invoiceservice/bin/linux_amd64 # Get a Dockerfile curl -o Dockerfile https://raw.githubusercontent.com/retgits/flogo-components/master/apps/invoiceservice/Dockerfile # Run the docker build command docker build -t $DOCKERHUBUSER/invoiceservice . And we\u0026rsquo;ll do the same for the second service as well.\n# Go to the right directory cd $ROOTDIR/$WORKDIR/paymentservice/bin/linux_amd64 # Get a Dockerfile curl -o Dockerfile https://raw.githubusercontent.com/retgits/flogo-components/master/apps/paymentservice/Dockerfile # Run the docker build command docker build -t $DOCKERHUBUSER/paymentservice . Running your Docker images Right now you have two new docker images available in your registry, which you could use to test the whole scenario as well. If you want to do that run the below commands in separate terminal windows\ndocker run --rm -it -p 9998:8080 $DOCKERHUBUSER/paymentservice docker run --rm -it -p 9999:8080 -e PAYMENTSERVICE=http://\u0026lt;YOUR IP\u0026gt;:9998/api/expected-date/:id $DOCKERHUBUSER/invoiceservice\u0026#34; Now you can test the flow by running\n# For the payment service curl --request GET --url http://localhost:9998/api/expected-date/1234 # For the invoice service curl --request GET --url http://localhost:9999/api/invoices/1234 For more information and sample messages check out the prebuilt docker images for these services on Docker Hub\ninvoiceservice paymentservice Speaking of Docker Hub\u0026hellip; you can push your docker containers to Docker Hub (assuming you have an account for it) by running\ndocker push $DOCKERHUBUSER/paymentservice:latest docker push $DOCKERHUBUSER/invoiceservice:latest On to Kubernetes The last step is to deploy to Kubernetes. To do that we need to download two additional files.\ncd $ROOTDIR/$WORKDIR curl -o invoice-svc.yml https://raw.githubusercontent.com/retgits/flogo-components/master/apps/invoiceservice/invoice-svc.yml curl -o payment-svc.yml https://raw.githubusercontent.com/retgits/flogo-components/master/apps/paymentservice/payment-svc.yml The payment-svc.yml file will create a deployment and a service resource in your Kubernetes cluster. For that we\u0026rsquo;ll use an existing docker image called retgits/paymentservice, which is the same as the one you just built. If you want you can update the yaml file before running the below command.\nkubectl apply -f payment-svc.yml You now have a docker container that is accessible as a service on Kubernetes. The payment service is accessible on port 80 of the cluster IP address that was assigned to it. If you want to try it out look for the CLUSTER-IP of the payment-svc in the output from kubectl get services\nkubectl run curl --image=radial/busyboxplus:curl -i --tty This will start a new buxybox terminal in your cluster. From there you can run\ncurl \u0026lt;CLUSTERIP\u0026gt;/api/expected-date/3456 which should return something like \u0026quot;{\u0026quot;expectedDate\u0026quot;:\u0026quot;2018-02-26\u0026quot;,\u0026quot;id\u0026quot;:\u0026quot;3456\u0026quot;}\nThe second service we\u0026rsquo;ll make available using the type: LoadBalancer which means that you can access it from outside your Kubernetes cluster. For this we\u0026rsquo;ll use the existing container retgits/invoiceservice. If you open the invoice.yml file you\u0026rsquo;ll see that there is an environment variable called PAYMENTSERVICE (line 24) which points to the DNS entry for the payment service. This way we can makes updates and potentially move the payment service around without having to update this service.\nkubectl apply -f invoice-svc.yml Done All done! You now have two Flogo apps running on a Kubernetes cluster which you invoke by sending a curl message to the Kubernetes IP address or localhost if you\u0026rsquo;re running Docker for Mac. You can execute a command like:\ncurl localhost:80/api/invoices/1234 which will return something like \u0026quot;{\u0026quot;amount\u0026quot;:1162,\u0026quot;balance\u0026quot;:718,\u0026quot;currency\u0026quot;:\u0026quot;USD\u0026quot;,\u0026quot;expectedPaymentDate\u0026quot;:\u0026quot;2018-03-02\u0026quot;,\u0026quot;id\u0026quot;:\u0026quot;1234\u0026quot;,\u0026quot;ref\u0026quot;:\u0026quot;INV-1234\u0026quot;}\u0026quot;\nHappy Kube-ing!!\n"
},
{
	"uri": "https://tibcosoftware.github.io/labs/helloworld/",
	"title": "My First App: Hello World",
	"tags": [],
	"description": "",
	"content": "Like with every programming language, a \u0026ldquo;Hello World\u0026rdquo; project gets you started with some basic fundamentals and Project Flogo really isn\u0026rsquo;t that different. This lab will get you started with the Flogo Web UI and building a simple flow.\nWhat you\u0026rsquo;ll need The Flogo Web UI This demo makes use of the Flogo Web UI. To make it easy to get started the Flogo Web UI is packaged up as a docker image which you can get from [docker hub](docker hub. To install Docker for your operating system click here for macOS and here for Windows. The Flogo Web UI contains everything you\u0026rsquo;ll need to build your Flogo apps, without ever writing code.\nIf you\u0026rsquo;re planning to run on a Windows machine older than Windows 10, you\u0026rsquo;ll need to install Docker Toolbox\nStep 1: Starting the Flogo Web UI To get started with the latest version of the Flogo Web UI paste this command in a terminal window:\ndocker run -it -p 3303:3303 flogo/flogo-docker:latest eula-accept The parameters after the docker run command are:\n-it: This parameter keeps a pseudo-tty terminal open and keeps the terminal running in interactive mode. The Flogo Web Ui will print logs to this terminal window -p 3303:3303: This parameter tells Docker to bind your computer\u0026rsquo;s port 3303 to the container\u0026rsquo;s port 3303 flogo/flogo-docker:latest: This parameter tells the Docker daemon which container you want to run. In this case it will try to get the latest version of flogo/flogo-docker eula-accept: This parameter says you\u0026rsquo;ve accepted the EULA agreement on our website After it is done starting the container, you\u0026rsquo;ll see something like the image below in your terminal.\nTo see the Flogo Web UI, open your favorite web browser, and navigate to http://localhost:3303. You\u0026rsquo;ll see our mascot Flynn there to greet you!\nStep 2: Create the app In Flogo terminology, an app is comprised of one or more triggers and flows (actions). The app itself is really just an organizational mechanism that can be leveraged when developing microservices \u0026amp; functions. An app contains a set of configurations, as well as triggers and a collection of flows.\nTo create a new app, open the Flogo Web UI and from there, click \u0026ldquo;New\u0026rdquo; to create a new microservice and give your new app a name. Click \u0026ldquo;Create a Flow\u0026rdquo; to create a new flow and give it any name that you want. Now click on the flow you just created and to open the canvas where you can design your flow.\nStep 3: Add a flow In Flogo, a flow is an implementation of an action and is the primary tool to implement business logic. A flow can consist of a number of different constructs:\nActivities: One or more activities that implement specific logic (for example write to a database, invoke a REST endpoint, etc) Links: Each activity is connected via a link (Links can contain conditional logic to alter the path of a flow) Flows, as previously stated in the triggers section, can exist without a trigger. Thus, flows operate very similar to functions, that is, a single flow can define its own input \u0026amp; output parameters. Thus, enabling a flow to be reused regardless of the trigger entrypoint To create a new flow you can click either the + New Flow button at the top or the Create a flow button in the middle of the screen.\nNo matter which you pick, you\u0026rsquo;ll be presented with a dialog to give your new flow a name and an optional description. Click Create to create the new flow and click on the newly created flow to open the editor.\nStep 4: Add a trigger Flogo is an event-driven framework. A trigger is the entrypoint for events to, as the name implies, trigger the functionality of your app. A trigger can be a subscriber on an MQTT topic, Kafka topic, HTTP REST interface or a specific IoT sensor. The trigger is responsible for accepting the incoming event and invoking one or more defined actions (flows).\nTo add a trigger, click on the \u0026ldquo;+\u0026rdquo; icon on the left hand side of the screen and select the Receive HTTP Message trigger.\nThe thing you want to log comes from the HTTP request. To get that parameter into the flow, you\u0026rsquo;ll need to create an Input parameter which you can do by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen.\nIn the Input tab, you need to configure the input parameter we will use later:\nParameter name: name Type: string The response to the HTTP request will be a message and the HTTP status code, and to be able to send data back you\u0026rsquo;ll need to have Output parameters. From the screen where you are now, select the Output tab and configure two parameters:\nParameter name: code Type: integer Now click on the + sign to add a new parameter\nParameter name: message Type: any Now it is time to configure the trigger to listen to HTTP messages. To start, click on the trigger and a new dialog will open with a bunch of options in the active Trigger settings tab. In this dialog you\u0026rsquo;ll have to provide:\nPort: The port on which your app will listen (set this to 9233) Method: The HTTP method that will trigger this flow (set this to GET) Path: The path that will route the messages to this flow (set this to /test/:name, the :name means that you can use that as a path parameter in your mappings). You will need to map the trigger to inputs and outputs as well. In that same dialog, select the second tab, Map to flow inputs. The parameter \u0026ldquo;a.. name\u0026rdquo; should be selected. You can see a list of trigger outputs under the text area. As you have set up earlier in \u0026ldquo;Trigger settings\u0026rdquo;, we want to use name as a path parameter. Select pathParams in the trigger output and add .name or simply type $.pathParams.name into the text area.\nOnce you\u0026rsquo;re done mapping to flow inputs, select the next tab, Map from flow output. Click on \u0026ldquo;123 code\u0026rdquo; to map it to one of the suggested flow output also called \u0026ldquo;123 code\u0026rdquo;. You should see $.code appear in the text area. Instead of selected the flow output, you can alternatively type or copy paste $.code directly into the text area without having to select a flow output in the suggested list.\nNow, still from the \u0026ldquo;Map from flow output\u0026rdquo; tab, select \u0026ldquo;* data\u0026rdquo; in the \u0026ldquo;Trigger Response\u0026rdquo; list on the left to map the output data. Again, you can directly type $.message in the text area, or select \u0026ldquo;* message\u0026rdquo; from the flow output list under the text area.\nFinally, you can click on save and close the dialog as you have successfully configured your trigger.\nThe URL on which our microservice will listen will be http://localhost:9233/test/:name (the :name is a parameter that you can replace with anything during runtime). If you made changes to any of the variables above, please make sure to change those in the rest of these examples.\nStep 5: Adding activities An activity is the unit of work that can be leveraged within a Flow. An activity can be any number of things and can be compared to a simple function in Go or any other procedural language, that is, an activity accepts input params and will return one or more objects on return, both input \u0026amp; output params are defined by the activity metadata. You’ll have to add some activities to the flow for it to do something. To add an activity click on the large + sign\nA list with all the activities the Flogo Web UI knows about will appear. From the list you can pick the \u0026ldquo;Log Message\u0026rdquo; activity (or use the searchbar to find it) and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Log Message\u0026rdquo; activity. Click on \u0026ldquo;a.. message\u0026rdquo; and type (or copy/paste) string.concat(\u0026quot;Hello \u0026quot;, $flow.name) in the box (on the right hand side of the screen).\nStep 6: Return data To complete the app, add a Return activity. To add an activity click on the large + sign.\nHover over the newly added activity to see the cog and select configure to bring up the modal to configure the activity. The return activity is always the last activity in a branch and sets the values that are returned to the trigger. Click on \u0026ldquo;123 code\u0026rdquo; and type 200 in the input field to set the HTTP Response code to 200. Now click on \u0026ldquo;a.. message\u0026rdquo; and type string.concat(\u0026quot;Hello \u0026quot;, $flow.name) in the input field. Finally click \u0026ldquo;Save\u0026rdquo; to complete the mapping.\nStep 7: Build Those were all the steps needed to design the flow, now let\u0026rsquo;s build an executable from it. On the main screen of your flow click on the \u0026lt; button on the top-left hand side of the screen. Click on build and select your operating system of choice! Flogo will compile a statically linked binary, meaning that there are no other dependencies that the executable you\u0026rsquo;re getting from the Flogo Web UI. No libraries to install, no frameworks to maintain or upgrade, just that one single binary that takes care of your flows.\nProject Flogo can build binaries for most platforms that exist. If you choose to build one for a unix based system (e.g. Linux or macOS) be sure to add the executable property to it (chmod +x \u0026lt;executable\u0026gt;).\nStep 8: Run your app To run the app double-click it (on Windows), or open a terminal and execute the downloaded binary. As you\u0026rsquo;ll do that, you\u0026rsquo;ll not only see the output of the log step, but you\u0026rsquo;ll see the same in your browser window as well. The URL on which our microservice will listen should be http://localhost:9233/test/:name (or might be different if you made changes in the previous steps). If you\u0026rsquo;re running it on your machine you can open a browser window and go to http://localhost:9233/test/flogo to see what the output was (spoiler alert: you\u0026rsquo;ll see \u0026quot;Hello flogo\u0026quot; in your web browser). To stop your app simply close the terminal window in which you started the app or press ctrl + c\n"
},
{
	"uri": "https://tibcosoftware.github.io/labs/timers/",
	"title": "My First App: Timers",
	"tags": [],
	"description": "",
	"content": "Timers are great to schedule stuff, and a great way to learn new technology! Use this lab to get familiar with some of the concepts of Flogo!\nWhat you\u0026rsquo;ll need The Flogo Web UI This demo makes use of the Flogo Web UI. To make it easy to get started the Flogo Web UI is packaged up as a docker image which you can get from docker hub. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo Web UI. The Flogo Web UI contains everything you\u0026rsquo;ll need to build your Flogo apps, without ever writing code.\nStep 1: Create the app In Flogo terminology, an app is comprised of one or more triggers and flows (actions). The app itself is really just an organizational mechanism that can be leveraged when developing microservices \u0026amp; functions. An app contains a set of configurations, as well as triggers and a collection of flows.\nTo create a new app, open the Flogo Web UI and from there, click \u0026ldquo;New\u0026rdquo; to create a new microservice and give your new app a name. Click \u0026ldquo;Create an Action\u0026rdquo; and select \u0026ldquo;Flow\u0026rdquo; to create a new flow and give it any name that you want. Now click on the flow you just created and to open the canvas where you can design your flow.\nStep 2: Add a trigger Flogo is an event-driven framework. A trigger is the entrypoint for events to trigger the functionality of your app. A trigger can be a subscriber on an MQTT topic, Kafka topic, HTTP REST interface or a specific IoT sensor. The trigger is responsible for accepting the incoming event and invoking one or more defined actions (flows).\nIn this case you want to start with a Timer. To add a trigger, click on the \u0026ldquo;+\u0026rdquo; icon on the left hand side of the screen and select the Timer trigger.\nNow it is time to configure the trigger. To start, click on the trigger and a new dialog will open with a bunch of options. In this dialog you\u0026rsquo;ll have to provide:\nstartDelay: The start delay (ex. 1s, 1m, 1h, 1h30m etc.), immediate if not specified repeatInterval: The repeat interval (ex. 1m, 1h, etc.), doesn\u0026rsquo;t repeat if not specified Click \u0026ldquo;save\u0026rdquo; to make sure everything is, well…, saved. You can click the little X on the top-right (no, not your browser…) to close the dialog window and go back to the flow.\nStep 3: Add activities An activity is the unit of work that can be leveraged within a Flow. An activity can be any number of things and can be compared to a simple function in Go or any other procedural language, that is, an activity accepts input params and will return one or more objects on return, both input \u0026amp; output params are defined by the activity metadata. You’ll have to add some activities to the flow for it to do something. To add an activity click on the large + sign\nA list with all the activities the Flogo Web UI knows about will appear. From the list you can pick the \u0026ldquo;Log\u0026rdquo; activity (or use the searchbar to find it) and click it to make sure it is added to the flow. As you hover over the newly added activity, a ellipsis (\u0026hellip;) will appear, click this and a menu will appear with options to configure or delete your activity. Click the gear icon to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Log Message\u0026rdquo; activity. Click on \u0026ldquo;a.. message\u0026rdquo; and type Hello World in the box (on the right hand side of the screen).\nWith all the updates, your flow should look something like the one below.\nStep 4: Build Those were all the steps needed to design the flow, now let\u0026rsquo;s build an executable from it. On the main screen of your flow click on the \u0026lt; button on the top-left hand side of the screen. Click on build and select your operating system of choice! Flogo will compile a statically linked binary, meaning that there are no other dependencies that the executable you\u0026rsquo;re getting from the Flogo Web UI. No libraries to install, no frameworks to maintain or upgrade, just that one single binary that takes care of your flows.\nStep 5: Run To run the app double-click it (on Windows), or open a terminal and execute:\n2019-07-25T07:46:46.224-0600\tINFO\t[flogo.engine] -\tStarting app [ app-build ] with version [ 0.0.1 ] 2019-07-25T07:46:46.224-0600\tINFO\t[flogo.engine] -\tEngine Starting... 2019-07-25T07:46:46.224-0600\tINFO\t[flogo.engine] -\tStarting Services... 2019-07-25T07:46:46.224-0600\tINFO\t[flogo] -\tActionRunner Service: Started 2019-07-25T07:46:46.224-0600\tINFO\t[flogo.engine] -\tStarted Services 2019-07-25T07:46:46.224-0600\tINFO\t[flogo.engine] -\tStarting Application... 2019-07-25T07:46:46.224-0600\tINFO\t[flogo] -\tStarting Triggers... 2019-07-25T07:46:46.224-0600\tINFO\t[flogo.trigger.timer] -\tScheduling a repeating timer 2019-07-25T07:46:46.224-0600\tINFO\t[flogo] -\tTrigger [ timer ]: Started 2019-07-25T07:46:46.224-0600\tINFO\t[flogo] -\tTriggers Started 2019-07-25T07:46:46.224-0600\tINFO\t[flogo.engine] -\tApplication Started 2019-07-25T07:46:46.224-0600\tINFO\t[flogo.engine] -\tEngine Started 2019-07-25T07:46:46.225-0600\tINFO\t[flogo.activity.log] -\tHello World 2019-07-25T07:46:46.225-0600\tINFO\t[flogo.flow] -\tInstance [19ffa126322448d04fee092d29a7ce7b] Done 2019-07-25T07:46:51.227-0600\tINFO\t[flogo.activity.log] -\tHello World 2019-07-25T07:46:51.227-0600\tINFO\t[flogo.flow] -\tInstance [1affa126322448d04fee092d29a7ce7b] Done Every 5 seconds a new entry will appear in the log.\n"
},
{
	"uri": "https://tibcosoftware.github.io/labs/paymentservice/",
	"title": "Payment Service",
	"tags": [],
	"description": "",
	"content": "The payment service is a service that uses a few communiy-driven activities to build out a Flogo microservice to generate a date when payment is expected. The lab also covers Input/Output mappings and Complex object mapping.\nWhat you\u0026rsquo;ll need The Flogo Web UI This demo makes use of the Flogo Web UI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo Web UI\nKubernetes demo This demo builds one of the services of the Kubernetes tutorial. After building this app, you might want to try and deploy it to Kubernetes too!\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\nThe project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations. Step 1: Create the app Open the Flogo Web UI and from there, click \u0026ldquo;New\u0026rdquo; to create a new microservice and give your new app a name. Click \u0026ldquo;Create a Flow\u0026rdquo; to create a new flow and give it any name that you want. Now click on the flow you just created and to open the canvas where you can design your flow.\nStep 2: Add a trigger Triggers are used to signal a flow to run. In this case you want to receive an HTTP message to generate the date. To add a trigger, click on the \u0026ldquo;+\u0026rdquo; icon on the left hand side of the screen and select the Receive HTTP Message trigger.\nThe invoice ID for which you need to generate a date comes from the HTTP request. To get that parameter into the flow, you\u0026rsquo;ll need to create an Input parameter which you can do by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen. For example, you can call the parameter \u0026ldquo;invoiceid\u0026rdquo;, keep the type as \u0026ldquo;string\u0026rdquo; and click save.\nThe response to the HTTP request will be a message and the HTTP status code, and to be able to send data back you\u0026rsquo;ll need to have Output parameters. You can create them by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen. From there, select Output and configure two parameters:\nParameter name: code Type: integer Now click on the + sign to add a new parameter\nParameter name: response Type: any Now it is time to configure the trigger to listen to HTTP messages. To start, click on the trigger and a new dialog will open with a bunch of options. In this dialog you\u0026rsquo;ll have to provide:\nPort: The port on which your app will listen (set this to 9233) Method: The HTTP method that will trigger this flow (set this to GET) Path: The path that will route the messages to this flow (set this to /api/expected-date/:invoiceId, the :invoiceId means that you can use that as a path parameter in your mappings) After that, click on \u0026ldquo;Map to flow inputs\u0026rdquo; to map the invoiceId from the HTTP trigger to the \u0026ldquo;invoiceid\u0026rdquo; parameter we created earlier. The parameter will already be selected because it is the only one. Since the data will come from the PATH parameters, you\u0026rsquo;ll need to type $.pathParams.invoiceId in the input box, which means the Flogo app will expect a PATH parameter called invoiceId to be present.\nWith the inputs taken care off, let\u0026rsquo;s look at the outputs. Click on \u0026ldquo;Map to flow outputs\u0026rdquo; to map the output parameters you created earlier to the response of the trigger. The code parameter will already be selected, so click on \u0026ldquo;123 code\u0026rdquo; in the Flow Output section to create the mapping. Now click on \u0026ldquo;response\u0026rdquo; in the Trigger Response section and select \u0026ldquo;* data\u0026rdquo; from the Flow Output section to create the mapping. Click \u0026ldquo;save\u0026rdquo; to make sure everything is, well…, saved. You can click the little X on the top-right (no, not your browser…) to close the dialog window and go back to the flow.\nThe URL on which our microservice will listen will be http://localhost:9233/api/expected-date/:invoiceId (the :invoiceId is a parameter that you can replace with anything during runtime). If you made changes to any of the variables above, please make sure to change those in the rest of these examples.\nStep 3: Add activities You’ll have to add some activities to the flow for it to do something. To add an activity click on the large + sign\nA list with all the activities the Flogo Web UI knows about will appear. The activity that is needed, to generate a random number, isn\u0026rsquo;t part of the out-of-the-box activities so you\u0026rsquo;ll need to import it. Click \u0026ldquo;Install new activity\u0026rdquo; and a dialog appears where you can paste (or type) the URL of where the Flogo Web UI can get the sources. For this activity you can use https://github.com/retgits/flogo-components/activity/randomnumber. From the updated list you can pick the \u0026ldquo;Random number\u0026rdquo; activity (or use the searchbar to find it) and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Random number\u0026rdquo; activity.\nmax: 10 (the maximum value the random number will have) min: 0 (the minimum value the random number will have) In the same way, add a new activity and this time install the \u0026ldquo;Add to date\u0026rdquo; activity to add a number of days to the current date. The URL you\u0026rsquo;ll need to use to install the activity is https://github.com/retgits/flogo-components/activity/addtodate.\nFrom the updated list you can pick the \u0026ldquo;Add to date\u0026rdquo; activity (or use the searchbar to find it) and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Add to date\u0026rdquo; activity.\ndate: \u0026quot;\u0026quot; (leave this blank, which means using the current date) units: \u0026quot;days\u0026quot; (this means you\u0026rsquo;ll add days. Other possible values are \u0026quot;years\u0026quot; and \u0026quot;months\u0026quot;) For the number you\u0026rsquo;ll need to perform a mapping. Select the activity input \u0026ldquo;number\u0026rdquo; and click on the grey carret next to the Random Number activity in the \u0026ldquo;Available Data\u0026rdquo; list. This will display a list of all the outputs from that activity and you\u0026rsquo;ll need to click on \u0026ldquo;result\u0026rdquo; to populate the input box with the value of that field. As your app is running, it will mean the output of that activity will be passed in as the input for this one.\nStep 4: Return data To complete the flow, add a Return activity. Hover over it to see the cog and select configure to bring up the modal to configure the activity. The return activity is always the last activity in a branch and sets the values that are returned to the trigger. Click on \u0026ldquo;123 code\u0026rdquo; and type 200 in the input field to set the HTTP Response code to 200.\nNow click on \u0026ldquo;* message\u0026rdquo; and type (or copy) the structure below. Finally click \u0026ldquo;Save\u0026rdquo; to complete the mapping.\n{\u0026#34;id\u0026#34;:\u0026#34;{{$flow.invoiceid}}\u0026#34;,\u0026#34;expectedDate\u0026#34;:\u0026#34;{{$activity[addtodate_3].result}}\u0026#34;} The above snippet maps the values from the REST service to fields that are sent back to the trigger. The mapping is done in a JavaScript-like syntax, so $flow.invoiceid means it will get the invoiceId that was used as an input parameter to the flow (the one you configured earlier) and the $activity[addtodate_3].result will get the result from the \u0026ldquo;Add to date\u0026rdquo; activity. The double curly braces are used as by Go\u0026rsquo;s templating engine.\nYour final flow should look something like the one below.\nStep 5: Build Those were all the steps needed to design the flow, now let\u0026rsquo;s build an executable from it. On the main screen of your flow click on the \u0026ldquo;\u0026lt;\u0026rdquo; button on the top-left hand side of the screen. That will bring you back to your microservice and from here you can select \u0026ldquo;Build\u0026rdquo;. Choose whichever operating system you\u0026rsquo;re running on to download the executable.\nStep 6: Run To see the results, start your app and run curl --request GET --url http://localhost:9233/api/expected-date/12345. That will give you a result like\n{\u0026#34;expectedDate\u0026#34;:\u0026#34;2018-10-01\u0026#34;,\u0026#34;id\u0026#34;:12345} "
},
{
	"uri": "https://tibcosoftware.github.io/labs/pubnub/",
	"title": "PubNub",
	"tags": [],
	"description": "",
	"content": "Building microservices is awesome, having them talk to each other is even more awesome! But in today\u0026rsquo;s world, you can\u0026rsquo;t be too careful when it comes to sending sensitive data across the wire. In this demo you explore how to build a simple microservice to receive the messages from PubNub and write that data to a file.\nWhat you\u0026rsquo;ll need The Flogo Web UI This demo makes use of the Flogo Web UI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo Web UI\nA PubNub account In order to work with PubNub, you\u0026rsquo;ll really need a PubNub account. Luckily, registration is very easy. Go to https://dashboard.pubnub.com/login and use \u0026ldquo;SIGN UP\u0026rdquo; to create a new account.\nStep 1: Create an app in PubNub After signing up, use the big red button to create a new app (the name doesn\u0026rsquo;t matter, and if you want you can change it later too). Now click on the newly created app and you\u0026rsquo;ll see a new KeySet. The Publish and Subscriber key are quite important as they make sure you can connect to your PubNub account.\nStep 2: Create an an in the Flogo Web UI Open the Flogo Web UI and from there, click \u0026ldquo;New\u0026rdquo; to create a new microservice and give your new app a name. Click \u0026ldquo;Create a Flow\u0026rdquo; to create a new flow and give it any name that you want. Now click on the flow you just created and to open the canvas where you can design your flow.\nStep 3: Import a new trigger Out of the box, Flogo doesn\u0026rsquo;t come with a trigger for PubNub so using the awesome SDK provided by the PubNub team we\u0026rsquo;ve built one for you! To install that into your Web UI, click on the + icon on the left hand side of the screen.\nFrom there click on \u0026ldquo;Install new\u0026rdquo; and paste \u0026ldquo;https://github.com/retgits/flogo-components/trigger/pubnubsubscriber\u0026rdquo; into the input dialog to get this new trigger. After the installation is completed, you can click on \u0026ldquo;Receive PubNub messages\u0026rdquo; to add the trigger to your app.\nStep 4: Configuration The thing we want to store in a file is the message coming from PubNub. To do so, you\u0026rsquo;ll need to create an Input parameter which you can do by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen. For example, you can call the parameter \u0026ldquo;pubnubmessage\u0026rdquo;, keep the type as \u0026ldquo;string\u0026rdquo; and click save.\nNow it is time to configure the trigger to listen to messages coming from PubNub. To start, click on the trigger and a new dialog will open with a bunch of options. In this dialog you\u0026rsquo;ll have to provide:\npublishKey: The key from PubNub (usually starts with pub-c) subscribeKey: The key from PubNub (usually starts with sub-c) channel: The channel on which messages will come (totally up to you to choose this) After that, click on \u0026ldquo;Map to flow inputs\u0026rdquo; to map the message from PubNub to the \u0026ldquo;pubnubmessage\u0026rdquo; parameter we created earlier. The parameter will already be selected because it is the only one, so the only task left is to click \u0026ldquo;* message\u0026rdquo; in the Trigger Output section and \u0026ldquo;save\u0026rdquo; to make sure everything is, well…, saved. You can click the little X on the top-right (no, not your browser…) to close the dialog window and go back to the flow.\nStep 5: Adding activities You’ll have to add some activities to the flow for it to do something. In this demo you\u0026rsquo;ll add two activities to the flow. The first activity will log the message and the second one will store the data in a file. To add an activity click on the other large + sign\nOn the right-hand side of the screen a list with all the activities the Flogo Web UI knows about will appear. From the list you can pick the \u0026ldquo;Log Message\u0026rdquo; activity and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Log Message\u0026rdquo; activity using data from all other activities and triggers in your flow. Right now, we have only the incoming data from PubNub so select \u0026ldquo;message\u0026rdquo; in the \u0026ldquo;Activity Inputs\u0026rdquo; section and expand the \u0026ldquo;flow (flow)\u0026rdquo; section (by clicking on the little black caret) to be able to select the \u0026ldquo;pubnubmessage\u0026rdquo;.\nNow hit the \u0026ldquo;save\u0026rdquo; button and we\u0026rsquo;re done with this part!\nNow we need to add a new activity to the Flogo Web UI to make sure you can add things to a file. Add a new activity, like you did before, and click \u0026ldquo;Install new activity\u0026rdquo; to get the same dialog as when installing the trigger.\nIn the dialog window you can paste \u0026ldquo;https://github.com/retgits/flogo-components/activity/writetofile\u0026rdquo;. Once the activity is installed you can select it from the list to add it to your flow. Again, hover over the newly added activity and expand the menu to configure your activity. For this activity you\u0026rsquo;ll have to configure all the parameters:\nAppend: Should the content be appended to the file or not? In this case we want to, so type \u0026ldquo;true\u0026rdquo; in the box Content: The content we want to add to the file. In this case it is the message from PubNub again, so expand the \u0026ldquo;flow (flow)\u0026rdquo; section (by clicking on the little black caret) and select the \u0026ldquo;pubnubmessage\u0026rdquo; Create: Should the file be created if it doesn\u0026rsquo;t exist? Well, yes, in this case that is probably a good idea so type \u0026ldquo;true\u0026rdquo; in the box Filename: The name of the file you want to write the data to. In this case you can call the file whatever you want, like \u0026ldquo;visitors.txt\u0026rdquo; (please be sure to add the double quotes as you type in the box) Click \u0026ldquo;save\u0026rdquo; to save the data and return to the main screen of your flow. The completed flow will look like\nStep 6: Build Those were all the steps needed to design the flow, now let\u0026rsquo;s build an executable from it. On the main screen of your flow click on the \u0026lt; button on the top-left hand side of the screen. That will bring you back to your microservice and from here you can select \u0026ldquo;Build\u0026rdquo; and choose your operating system of choice. That will tell the Flogo Web UI to go build your microservice and give you a tiny executable in return (about 12mb).\nStep 7: Test You can run your microservice by either double-clicking it (on Windows) or using a terminal window to run your app (macOS or Linux). If the app started successfully it will give you a message like: 2018-08-06 21:20:02.867 INFO [engine] - Received status [pubnub.PNConnectedCategory], this is expected for a subscribe, this means there is no error or issue whatsoever\nTo test the microservice you can use the PubNub debug console.\nIn the \u0026ldquo;Default Channel\u0026rdquo; you\u0026rsquo;ll have to type the same channel name as you configured in your Flogo app (MyChannel, in this example). You can click \u0026ldquo;ADD CLIENT\u0026rdquo; to create a new client which will be able to send and receive data. The cool thing that PubNub offers, is that you don\u0026rsquo;t have to open any firewall ports to have the debug console and the microservice talk to each other. At the bottom of the page it will now say {\u0026quot;text\u0026quot;:\u0026quot;Enter Message Here\u0026quot;}, which is the message that you can send to your microservice. Either hit \u0026ldquo;SEND\u0026rdquo; or perhaps replace the default message with something like {\u0026quot;Hello\u0026quot;:\u0026quot;World\u0026quot;}. After you click \u0026ldquo;SEND\u0026rdquo; the exact message will appear in the window where your microservice is running\nAnd in the log file that was created in the same location as your app\n"
},
{
	"uri": "https://tibcosoftware.github.io/labs/raspberry-iot/",
	"title": "Raspberry Pi",
	"tags": [],
	"description": "",
	"content": "A Raspberry Pi is probably one of the most well-known small single-board computers built to promote the teaching of basic computer science, and increasingly used for cool IoT projects. Flogo runs perfectly on these small devices, and in this lab you\u0026rsquo;ll build a sample to read and write data to the GPIO pins of the device\nWhat you\u0026rsquo;ll need The Flogo Web UI This demo makes use of the Flogo Web UI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo Web UI\nDevices You\u0026rsquo;ll definitely want to have a Raspberry Pi, to run the app!\nStep 1: Create the app Open the Flogo Web UI and from there, click \u0026ldquo;New\u0026rdquo; to create a new microservice and give your new app a name. Click \u0026ldquo;Create a Flow\u0026rdquo; to create a new flow and give it any name that you want. Now click on the flow you just created and to open the canvas where you can design your flow.\nStep 2: Add a trigger Triggers are used to signal a flow to run. In this case you want to receive an HTTP message to turn on or off the lights. To add a trigger, click on the + icon on the left hand side of the screen and select the Receive HTTP Message trigger.\nThe response to the HTTP request will be a message and the HTTP status code, and to be able to send data back you\u0026rsquo;ll need to have Output parameters. You can create them by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen. From there, select Output and configure two parameters:\nParameter name: code Type: integer Now click on the + sign to add a new parameter\nParameter name: message Type: string Now it is time to configure the trigger to listen to HTTP messages. To start, click on the trigger and a new dialog will open with a bunch of options. In this dialog you\u0026rsquo;ll have to provide:\nPort: The port on which your app will listen (set this to 9233) Method: The HTTP method that will trigger this flow (set this to GET) Path: The path that will route the messages to this flow (this can be anything, like /light/status) After that, click on \u0026ldquo;Map to flow outputs\u0026rdquo; to map the output parameters you created earlier to the response of the trigger. The code parameter will already be selected, so click on \u0026ldquo;123 code\u0026rdquo; in the Flow Output section to create the mapping. Now click on \u0026ldquo;message\u0026rdquo; in the Trigger Response section and select \u0026ldquo;* data\u0026rdquo; from the Flow Output section to create the mapping. Click \u0026ldquo;save\u0026rdquo; to make sure everything is, well…, saved. You can click the little X on the top-right (no, not your browser…) to close the dialog window and go back to the flow.\nStep 3: Add activities You’ll have to add some activities to the flow for it to do something. To add an activity click on the other large + sign\nA list with all the activities the Flogo Web UI knows about will appear. From the list you can pick the \u0026ldquo;Log Message\u0026rdquo; activity (or use the searchbar to find it) and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Log Message\u0026rdquo; activity. Click on \u0026ldquo;a.. message\u0026rdquo; and type Received request. in the box (on the right hand side of the screen).\nIn the same way you just added the Log activity, now add a Control GPIO activity and configure it in the same way with:\nmethod: Direction pinNumber: 23 direction: Output This will tell the app you\u0026rsquo;ll want to use pin number 23.\nAdd another Control GPIO activity and configure it in the same way with:\nmethod: Read State pinNumber: 23 This will tell the app you want to know the output state of pin number 23.\nYour flow should look something like the one below.\nStep 4: Adding a branch To be able to switch from on to off and vice versa, you\u0026rsquo;ll need to create two branches. One that turns off the light if it was on and one that does the opposite. You\u0026rsquo;ll start by creating the \u0026ldquo;Turn it on\u0026rdquo; branch.\nAs you hover over the activity, a cog will appear and as you hover over that thing, a menu will appear to create a branch from your activity.\nClick anywhere on the branch to be able to set a condition. The condition is a JavaScript-like syntax $activity[gpio_4].result==0. You can create the condition by simply typing it into the textbox. Where it says gpio_4 in the condition, you might need to change that to match the ID of the activity you added last (it will have the name \u0026ldquo;Control GPIO(2)\u0026rdquo;).\nAdd a new Log Message activity (click on the + right behind the created branch) and as you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In the modal that now appears, select \u0026ldquo;a.. message\u0026rdquo; to tell the app what the message is that will be logged. Now click on the caret next to the second GPIO activity to expand it and click \u0026ldquo;123 result\u0026rdquo; to tell the app to map the result from that activity to the message that will be logged.\nAdd another Control GPIO activity (yes, a lot of GPIO activities are used in this flow\u0026hellip;) and configure it in the same way you did with the previous activities, but with the values:\nmethod: Set State pinNumber: 23 state: high To complete the branch, add a Return activity. Hover over it to see the cog and select configure to bring up the modal to configure the activity. The return activity is always the last activity in a branch and sets the values that are returned to the trigger. Click on \u0026ldquo;123 code\u0026rdquo; and type 200 in the input field to set the HTTP Response code to 200.\nNow click on \u0026ldquo;a.. message\u0026rdquo; and type \u0026ldquo;Updated light to high successfully\u0026rdquo; (the quotes are needed). Finally click \u0026ldquo;Save\u0026rdquo; to complete the mapping.\nWith all the updates, your flow should look something like the one below.\nStep 5: Adding another branch To create the second branch, the \u0026ldquo;Turn it off\u0026rdquo; branch, select the activity from which you created the first branch. Create a branch in the same way, by hovering over the activity first. As you hover over the activity, a cog will appear and as you hover over that thing, a menu will appear to create a branch from your activity.\nClick anywhere on the branch to be able to set a condition. This time, set the condition to $activity[gpio_4].result==1. Where it says gpio_4 in the condition, you might need to change that to match the ID of the activity you added last (it will have the name \u0026ldquo;Control GPIO(2)\u0026rdquo;).\nAdd a new Log Message activity (click on the + right behind the newly created branch) and as you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In the modal that now appears, select \u0026ldquo;a.. message\u0026rdquo; to tell the app what the message is that will be logged. Now click on the caret next to the second GPIO activity to expand it and click \u0026ldquo;123 result\u0026rdquo; to tell the app to map the result from that activity to the message that will be logged.\nAdd a Control GPIO activity (we promise, this is the last GPIO activity\u0026hellip;) and configure it in the same way you did with the previous activities, but with the values:\nmethod: Set State pinNumber: 23 state: low This branch should be completed with a Return activity as well. Hover over it to see the cog and select configure to bring up the modal to configure the activity. Click on \u0026ldquo;123 code\u0026rdquo; and type 200 in the input field to set the HTTP Response code to 200 and this time set the field \u0026ldquo;a.. message\u0026rdquo; to \u0026ldquo;Updated light to low successfully\u0026rdquo; (the quotes are needed). Finally click \u0026ldquo;Save\u0026rdquo; to complete the mapping.\nWith all the updates, your final flow should look something like the one below.\nStep 6: Build Those were all the steps needed to design the flow, now let\u0026rsquo;s build an executable from it. On the main screen of your flow click on the \u0026lt; button on the top-left hand side of the screen. That will bring you back to your microservice and from here you can select \u0026ldquo;Build\u0026rdquo; and choose linux/arm to make sure it is capable of running on a Raspberry Pi.\nStep 7: Run To run your app copy it to your Raspberry Pi and run curl --request GET --url http://localhost:9233/lights/status (or replace localhost with the IP address of your device)\n"
},
{
	"uri": "https://tibcosoftware.github.io/labs/serverless/",
	"title": "Serverless Framework",
	"tags": [],
	"description": "",
	"content": "Building serverless apps is awesome! As a developer you don\u0026rsquo;t have to worry about provisioning or maintaining servers, and you only have to create the code that you need to power your next business idea! Deploying such apps is made super easy by the team at Serverless Framework.With the Serverless Framework, you can configure which events should trigger it, where to deploy it and what kind of resources it is allowed to use without going into the AWS console.\nWhat you\u0026rsquo;ll need Serverless Framework You\u0026rsquo;ll need to have the Serverless Framework installed. If you haven\u0026rsquo;t done that yet, now would be a great time to do so!\nAWS account To finally deploy your apps you\u0026rsquo;ll need an AWS account. If you haven\u0026rsquo;t signed up yet, this would be a great time to do that too.\nStep 1: Using the template The first step is to create a sample project based on the Flogo template.\nserverless create -u https://github.com/tibcosoftware/flogo/tree/master/serverless -p myservice That command just generated a bunch of files for you\nmyservice \u0026lt;-- A new directory with the name of your service ├── hello \u0026lt;-- A folder with the sources of your function │ ├── function.go \u0026lt;-- A Hello World function │ └── main.go \u0026lt;-- The Lambda trigger code, created by Flogo ├── .gitignore \u0026lt;-- A .gitignore file to ignore the things you don\u0026#39;t want in git ├── Makefile \u0026lt;-- A Makefile to build and deploy even faster ├── README.md \u0026lt;-- A quickstart guide └── serverless.yaml \u0026lt;-- The Serverless Framework template The content of main.go comes directly from the Lambda trigger. The function.go file has three methods that make up the entire app\ninit: The init method makes sure that everything is ready to go. It sets the default loglevels, creates an app by calling shimApp() and ultimately starts the engine shimApp: shimApp is used to build a new Flogo app and register the Lambda trigger with the engine. The shimapp is used by the shim, which triggers the engine every time an event comes into Lambda. It registers the method that it should call each time and in this case that method is RunActivities RunActivities: RunActivities is where the magic happens. This is where you get the input from any event that might trigger your Lambda function in a map called evt (which is part of the inputs). The sample will simply log \u0026ldquo;Go Serverless v1.x! Your function executed successfully!\u0026rdquo; and return the same as a response. The trigger, in main.go, will take care of marshalling it into a proper response for the API Gateway Step 2: Build and Deploy To build the executable that you want to deploy to Lambda, you can run make or make build. That command, in turn, executes two other commands:\ngo generate ./...: In order to run the activities and triggers that you have uses, the Flogo engine needs to have all the metadata available. This command generates the metadata so that it can be compiled into the executable env GOOS=linux go build -ldflags=\u0026quot;-s -w\u0026quot; -o bin/hello hello/*.go: This command creates the executable (which should run on Linux) from the sources in the hello folder and stores the result (a file called hello) in the bin folder. To deploy the app run make deploy or, if you don\u0026rsquo;t want to use make, run sls deploy --verbose to get the same result. This command will deploy your function to AWS Lambda.\nThe output on your screen will have something like what is pasted below:\n\u0026lt;snip\u0026gt; Service Information service: myservice stage: dev region: us-east-1 stack: myservice-dev api keys: None endpoints: GET - https://xxx.execute-api.us-east-1.amazonaws.com/dev/hello functions: hello: myservice-dev-hello \u0026lt;snip\u0026gt; Step 3: Test it Using cURL you can test your new function\ncurl --request GET --url https://xxx.execute-api.us-east-1.amazonaws.com/dev/hello --header \u0026#39;content-type: application/json\u0026#39; The above command will call your function and return a result:\n{\u0026#34;message\u0026#34;: \u0026#34;Go Serverless v1.x! Your function executed successfully!\u0026#34;} Step 4: Adding a POST operation That was pretty easy, and pretty cool, but not really useful. The next step is all about updating the code to not only handle GET, but also POST operations and provide a more personalized response.\nThe first thing is to update the serverless.yml file with a new event handler. Around line 58 of the file you\u0026rsquo;ll find the events and the types of events that can trigger your app. It already has an entry for GET, copy and paste that and change the method to POST.\nfunctions: hello: handler: bin/hello events: - http: path: hello method: get - http: path: hello method: post Step 5: Build the code The second part is to update the RunActivities method. In this step you\u0026rsquo;ll walk through the entire method.\nIn order to distinguish the two HTTP methods, you\u0026rsquo;ll have to look at the httpMethod element of the incoming message:\n// Get the HTTP method from the event method := inputs[\u0026#34;evt\u0026#34;].Value().(map[string]interface{})[\u0026#34;httpMethod\u0026#34;].(string) // Create a variable for the message var message string // Decide which way to take switch method { case \u0026#34;GET\u0026#34;: case \u0026#34;POST\u0026#34;: } Creating the response, so after the switch statement is completed, will still be the same:\n// Using a Flogo activity to log the message in := map[string]interface{}{\u0026#34;message\u0026#34;: message} _, err := flogo.EvalActivity(\u0026amp;log.LogActivity{}, in) if err != nil { return nil, err } // The response from the Lambda function is always in the form of a JSON message. // In this case we\u0026#39;re creating a structure with a single element called // message responseData := make(map[string]interface{}) responseData[\u0026#34;message\u0026#34;] = message // Because we\u0026#39;re sending the result back to the API Gateway, it will expect to have // both an HTTP result code (called code) and some response data. In this case we\u0026#39;re // sending back the data object we created earlier response := make(map[string]*data.Attribute) response[\u0026#34;code\u0026#34;], _ = data.NewAttribute(\u0026#34;code\u0026#34;, data.TypeInteger, 200) response[\u0026#34;data\u0026#34;], _ = data.NewAttribute(\u0026#34;data\u0026#34;, data.TypeAny, responseData) return response, nil In case of a GET operation, the message should still be the same. You can update the GET part by pasting in message = \u0026quot;Go Serverless v1.x! Your function executed successfully!\u0026quot;\nIn case of a POST operation, the message will be a little different. In that case you want to reply with the name of the person that called your function.\n// API Gateway passes in the body as a string, so the first step // is to parse the body to a JON object, or map[string]interface{} in Go var eventBody map[string]interface{} if err := json.Unmarshal([]byte(inputs[\u0026#34;evt\u0026#34;].Value().(map[string]interface{})[\u0026#34;body\u0026#34;].(string)), \u0026amp;eventBody); err != nil { return nil, err } // The message you want to log message = fmt.Sprintf(\u0026#34;%v is going all in on Serverless v1.x!\u0026#34;, eventBody[\u0026#34;name\u0026#34;]) Putting everything together, the new method will look like\n// Get the HTTP method from the event method := inputs[\u0026#34;evt\u0026#34;].Value().(map[string]interface{})[\u0026#34;httpMethod\u0026#34;].(string) // Create a variable for the message var message string // Decide which way to take switch method { case \u0026#34;GET\u0026#34;: message = \u0026#34;Go Serverless v1.x! Your function executed successfully!\u0026#34; case \u0026#34;POST\u0026#34;: // API Gateway passes in the body as a string, so the first step // is to parse the body to a JON object, or map[string]interface{} in Go var eventBody map[string]interface{} if err := json.Unmarshal([]byte(inputs[\u0026#34;evt\u0026#34;].Value().(map[string]interface{})[\u0026#34;body\u0026#34;].(string)), \u0026amp;eventBody); err != nil { return nil, err } // The message you want to log message = fmt.Sprintf(\u0026#34;%v is going all in on Serverless v1.x!\u0026#34;, eventBody[\u0026#34;name\u0026#34;]) } // Using a Flogo activity to log the message in := map[string]interface{}{\u0026#34;message\u0026#34;: message} _, err := flogo.EvalActivity(\u0026amp;log.LogActivity{}, in) if err != nil { return nil, err } // The response from the Lambda function is always in the form of a JSON message. // In this case we\u0026#39;re creating a structure with a single element called // message responseData := make(map[string]interface{}) responseData[\u0026#34;message\u0026#34;] = message // Because we\u0026#39;re sending the result back to the API Gateway, it will expect to have // both an HTTP result code (called code) and some response data. In this case we\u0026#39;re // sending back the data object we created earlier response := make(map[string]*data.Attribute) response[\u0026#34;code\u0026#34;], _ = data.NewAttribute(\u0026#34;code\u0026#34;, data.TypeInteger, 200) response[\u0026#34;data\u0026#34;], _ = data.NewAttribute(\u0026#34;data\u0026#34;, data.TypeAny, responseData) return response, nil Step 6: Build and Deploy To build and deploy the updates you can use one command: make deploy. This command will build the new executable and deploy your function to AWS Lambda.\nThe output on your screen will have something like what is pasted below:\n\u0026lt;snip\u0026gt; Service Information service: myservice stage: dev region: us-east-1 stack: myservice-dev api keys: None endpoints: GET - https://xxx.execute-api.us-east-1.amazonaws.com/dev/hello POST - https://xxx.execute-api.us-east-1.amazonaws.com/dev/hello functions: hello: myservice-dev-hello \u0026lt;snip\u0026gt; Step 7: Test it\u0026hellip; again Using cURL you can test that your function still works for a GET operation. The command\ncurl --request GET --url https://xxx.execute-api.us-east-1.amazonaws.com/dev/hello --header \u0026#39;content-type: application/json\u0026#39; Should still respond with:\n{\u0026#34;message\u0026#34;: \u0026#34;Go Serverless v1.x! Your function executed successfully!\u0026#34;} When you POST a message, though\ncurl --request POST --url https://xxx.execute-api.us-east-1.amazonaws.com/dev/hello --header \u0026#39;content-type: application/json\u0026#39; --data \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;Flogo\u0026#34;}\u0026#39; The result should be different\n{\u0026#34;message\u0026#34;: \u0026#34;Flogo is going all in on Serverless v1.x!\u0026#34;} "
},
{
	"uri": "https://tibcosoftware.github.io/labs/streams-aggregate/",
	"title": "Streams: Aggregate",
	"tags": [],
	"description": "",
	"content": "Project Flogo is an ultra-light, Go-based open source ecosystem for building event-driven apps. It provides a bunch of capabilities to build those apps, like:\nIntegration Flows: Application Integration process engine with conditional branching and a visual development environment Stream Processing: a simple pipeline-based stream processing action with event joining capabilities across multiple triggers \u0026amp; aggregation over time windows Contextual Decisioning: Declarative Rules for Real-time Contextual Decisions In this tutorial you will learn how to use the Stream Processing capability in Flogo\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\nThe project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations. Step 1: Prepare the app The first step to create a Flogo streams app is to create a quick, barebones Flogo app using the Flogo CLI. Using the Flogo CLI, you\u0026rsquo;ll need to specify that it should get the master branch of both flogo-lib to make sure you can build a streaming app correctly. The command to execute is\nflogo create -flv \u0026lt;branch you need\u0026gt; \u0026lt;appname\u0026gt; So in your case, using the name aggregator, the command will be\nflogo create -flv github.com/TIBCOSoftware/flogo-contrib/activity/log@master,github.com/TIBCOSoftware/flogo-lib/app/resource@master aggregator Step 2: Create the JSON file Open up the flogo.json file that was created in the aggregator directory and delete all the contents. For this tutorial, you\u0026rsquo;ll be guided through the different sections of the flogo.json and what they mean:\nTrigger Action Resources Stages General stuff Before you can get to define the app, you\u0026rsquo;ll need to define some metadata that the app model needs as well. The fields name, type, version, and appModel describe the metadata of the app and the JSON model you\u0026rsquo;re building through this tutorial. For this tutorial, that part of the file will look like:\n{ \u0026#34;name\u0026#34;: \u0026#34;aggregator\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;flogo:app\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;appModel\u0026#34;: \u0026#34;1.0.0\u0026#34;, } Trigger Flogo is an event-driven framework. A trigger is the entrypoint for events. A trigger can be a subscriber on an MQTT topic, Kafka topic, HTTP REST interface or a specific IoT sensor. The trigger is responsible for accepting the incoming event and invoking one or more defined actions. In this case, the trigger will be the REST trigger that comes out-of-the-box with Flogo. The trigger has a bunch of configurations that are important:\nIt will listen on port 9234 It will have a GET method registered for the endpoint /aggregate/:val As messages come in, it will call an action with id simple_agg The input to that action is a parameter called input and is assigned the value of the PATH parameter val Since there could be multiple triggers, the triggers element is an array. In this tutorial, though, you\u0026rsquo;ll only use one REST trigger\n{ \u0026#34;triggers\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;receive_http_message\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Receive HTTP Message\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;port\u0026#34;: \u0026#34;9234\u0026#34; }, \u0026#34;handlers\u0026#34;: [ { \u0026#34;settings\u0026#34;: { \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/aggregate/:val\u0026#34; }, \u0026#34;action\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;simple_agg\u0026#34;, \u0026#34;mappings\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;mapTo\u0026#34;: \u0026#34;input\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;assign\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$.pathParams.val\u0026#34; } ] } } } ] } ] } Action An action is a generic implementation for processing the incoming event. Different types of actions can be implemented, thus defining different methods by which an incoming event can be processed. In your case, a pipeline is needed (which is implemented by the github.com/project-flogo/stream action) and it will dispatch the event to the resource with the URI res://pipeline:simple_agg\n{ \u0026#34;actions\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;simple_agg\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;github.com/project-flogo/stream\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;pipelineURI\u0026#34;: \u0026#34;res://pipeline:simple_agg\u0026#34; } } ] } Resources The resources are the actual workhorses of the Flogo app. They define, among a ton of other things, the sequences in which activities have to be executed, rules that need to be followed and parameters that need to be mapped. First, let\u0026rsquo;s look at the metadata of the resource that defines the input and the output. In this case the input is an integer called input and the output is an integer called result.\n{ \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;pipeline:simple_agg\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;metadata\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;input\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } ], \u0026#34;output\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;result\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } ] }, } Stages The stages, as the name implies, define the sequential steps that a pipeline needs to perform. The first step is the aggregator activity, which:\nSums all the inputs Using a time tumbling window of 5000 milliseconds (5 seconds) The input to the activity is simply a straight-through mapping of the input parameter The second activity is a log activity, where the message field is mapped straight from the result field of the aggregator activity. Note that in stream actions, unlike flow actions, only the output of the preceding activity is available and not all other outputs.\n{ \u0026#34;stages\u0026#34;: [ { \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/activity/aggregate\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;function\u0026#34;: \u0026#34;sum\u0026#34;, \u0026#34;windowType\u0026#34;: \u0026#34;timeTumbling\u0026#34;, \u0026#34;windowSize\u0026#34;: \u0026#34;5000\u0026#34; }, \u0026#34;input\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;=$.input\u0026#34; } }, { \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026#34;, \u0026#34;input\u0026#34;: { \u0026#34;message\u0026#34;: \u0026#34;=$.result\u0026#34; } } ] } The completed flow The complete flogo.json will look like\n{ \u0026#34;name\u0026#34;: \u0026#34;aggregator\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;flogo:app\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;appModel\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;triggers\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;receive_http_message\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Receive HTTP Message\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;port\u0026#34;: \u0026#34;9234\u0026#34; }, \u0026#34;handlers\u0026#34;: [ { \u0026#34;settings\u0026#34;: { \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/aggregate/:val\u0026#34; }, \u0026#34;action\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;simple_agg\u0026#34;, \u0026#34;mappings\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;mapTo\u0026#34;: \u0026#34;input\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;assign\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$.pathParams.val\u0026#34; } ] } } } ] } ], \u0026#34;actions\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;simple_agg\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;github.com/project-flogo/stream\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;pipelineURI\u0026#34;: \u0026#34;res://pipeline:simple_agg\u0026#34; } } ], \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;pipeline:simple_agg\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;metadata\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;input\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } ], \u0026#34;output\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;result\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } ] }, \u0026#34;stages\u0026#34;: [ { \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/activity/aggregate\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;function\u0026#34;: \u0026#34;sum\u0026#34;, \u0026#34;windowType\u0026#34;: \u0026#34;timeTumbling\u0026#34;, \u0026#34;windowSize\u0026#34;: \u0026#34;5000\u0026#34; }, \u0026#34;input\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;=$.input\u0026#34; } }, { \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026#34;, \u0026#34;input\u0026#34;: { \u0026#34;message\u0026#34;: \u0026#34;=$.result\u0026#34; } } ] } } ] } Step 3: Install dependencies In your app, you\u0026rsquo;re making use of a few external dependencies that you need to install into your app for the Go compiler to be able to successfully build the app. To install external dependencies, you need to run\nflogo install \u0026lt;dependency location\u0026gt; So in the case of this tutorial, you\u0026rsquo;ll need to run\nflogo install github.com/project-flogo/stream flogo install github.com/TIBCOSoftware/flogo-lib/app/resource flogo install github.com/TIBCOSoftware/flogo-contrib/activity/aggregate Step 4: Build the app The next step is to build the executable. To build a flogo app from the source you can execute the command flogo build -e, which tells the flogo cli to build the app (and place it in a bin directory) and embed all configuration into a single executable\nflogo build -e Step 5: Run To run the app you just built, open a terminal and run\ncd bin ./aggregator You can send commands to it using cURL\ncurl --request GET --url http://localhost:9234/aggregate/1 If you send a number of requests within the 5000 millisecond window, the Flogo app will aggregate them and provide the sum of the numbers:\n2018-10-04 07:47:31.444 INFO [engine] - Engine Starting... 2018-10-04 07:47:31.444 INFO [engine] - Starting Services... 2018-10-04 07:47:31.444 INFO [engine] - Started Services 2018-10-04 07:47:31.444 INFO [engine] - Starting Triggers... 2018-10-04 07:47:31.445 INFO [engine] - Trigger [ receive_http_message ]: Started 2018-10-04 07:47:31.445 INFO [engine] - Triggers Started 2018-10-04 07:47:31.445 INFO [engine] - Engine Started 2018-10-04 07:48:41.514 INFO [trigger-flogo-rest] - Received request for id \u0026#39;receive_http_message\u0026#39; 2018-10-04 07:48:42.224 INFO [trigger-flogo-rest] - Received request for id \u0026#39;receive_http_message\u0026#39; 2018-10-04 07:48:42.784 INFO [trigger-flogo-rest] - Received request for id \u0026#39;receive_http_message\u0026#39; 2018-10-04 07:48:43.351 INFO [trigger-flogo-rest] - Received request for id \u0026#39;receive_http_message\u0026#39; 2018-10-04 07:48:46.515 INFO [activity-flogo-log] - 4 "
},
{
	"uri": "https://tibcosoftware.github.io/labs/streams-filter/",
	"title": "Streams: Counter",
	"tags": [],
	"description": "",
	"content": "Project Flogo is an ultra-light, Go-based open source ecosystem for building event-driven apps. It provides a bunch of capabilities to build those apps, like:\nIntegration Flows: Application Integration process engine with conditional branching and a visual development environment Stream Processing: a simple pipeline-based stream processing action with event joining capabilities across multiple triggers \u0026amp; aggregation over time windows Contextual Decisioning: Declarative Rules for Real-time Contextual Decisions In this tutorial you will learn how to use the Stream Processing capability in Flogo\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\nThe project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations. Step 1: Prepare the app The first step to create a Flogo streams app is to create a quick, barebones Flogo app using the Flogo CLI. Using the Flogo CLI, you\u0026rsquo;ll need to specify that it should get the master branch of both flogo-lib to make sure you can build a streaming app correctly. The command to execute is\nflogo create -flv \u0026lt;branch you need\u0026gt; \u0026lt;appname\u0026gt; So in your case, using the name streamfilter, the command will be\nflogo create -flv github.com/TIBCOSoftware/flogo-contrib/activity/log@master,github.com/TIBCOSoftware/flogo-lib/app/resource@master streamfilter Step 2: Create the JSON file Open up the flogo.json file that was created in the streamfilter directory and delete all the contents. For this tutorial, you\u0026rsquo;ll be guided through the different sections of the flogo.json and what they mean:\nTrigger Action Resources Stages General stuff Before you can get to define the app, you\u0026rsquo;ll need to define some metadata that the app model needs as well. The fields name, type, version, and appModel describe the metadata of the app and the JSON model you\u0026rsquo;re building through this tutorial. For this tutorial, that part of the file will look like:\n{ \u0026#34;name\u0026#34;: \u0026#34;streamfilter\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;flogo:app\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;appModel\u0026#34;: \u0026#34;1.0.0\u0026#34;, } Trigger Flogo is an event-driven framework. A trigger is the entrypoint for events. A trigger can be a subscriber on an MQTT topic, Kafka topic, HTTP REST interface or a specific IoT sensor. The trigger is responsible for accepting the incoming event and invoking one or more defined actions. In this case, the trigger will be the REST trigger that comes out-of-the-box with Flogo. The trigger has a bunch of configurations that are important:\nIt will listen on port 9234 It will have a GET method registered for the endpoint /filter/:val As messages come in, it will call an action with id simple_filter The input to that action is a parameter called input and is assigned the value of the PATH parameter val Since there could be multiple triggers, the triggers element is an array. In this tutorial, though, you\u0026rsquo;ll only use one REST trigger\n{ \u0026#34;triggers\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;receive_http_message\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Receive HTTP Message\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;port\u0026#34;: \u0026#34;9234\u0026#34; }, \u0026#34;handlers\u0026#34;: [ { \u0026#34;settings\u0026#34;: { \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/filter/:val\u0026#34; }, \u0026#34;action\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;simple_filter\u0026#34;, \u0026#34;mappings\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;mapTo\u0026#34;: \u0026#34;input\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;assign\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$.pathParams.val\u0026#34; } ] } } } ] } ], } Action An action is a generic implementation for processing the incoming event. Different types of actions can be implemented, thus defining different methods by which an incoming event can be processed. In your case, a pipeline is needed (which is implemented by the github.com/project-flogo/stream action) and it will dispatch the event to the resource with the URI res://pipeline:simple_filter\n{ \u0026#34;actions\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;simple_filter\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;github.com/project-flogo/stream\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;pipelineURI\u0026#34;: \u0026#34;res://pipeline:simple_filter\u0026#34; } } ] } Resources The resources are the actual workhorses of the Flogo app. They define, among a ton of other things, the sequences in which activities have to be executed, rules that need to be followed and parameters that need to be mapped. First, let\u0026rsquo;s look at the metadata of the resource that defines the input and the output. In this case the input is an integer called input (and no output).\n{ \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;pipeline:simple_filter\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;metadata\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;input\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } ] }, } Stages The stages, as the name implies, define the sequential steps that a pipeline needs to perform. The first step is the filter activity, which:\nFilters all inputs using the non-zero filter The input to the activity is simply a straight-through mapping of the input parameter The second activity is a log activity, where the message field is mapped straight from the value field of the filter activity. Note that in stream actions, unlike flow actions, only the output of the preceding activity is available and not all other outputs.\n{ \u0026#34;stages\u0026#34;: [ { \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/activity/filter\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;non-zero\u0026#34;, \u0026#34;proceedOnlyOnEmit\u0026#34;: true }, \u0026#34;input\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;=$.input\u0026#34; } }, { \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026#34;, \u0026#34;input\u0026#34;: { \u0026#34;message\u0026#34;: \u0026#34;=$.value\u0026#34; } } ] } The completed flow The complete flogo.json will look like\n{ \u0026#34;name\u0026#34;: \u0026#34;streamfilter\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;flogo:app\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;appModel\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;triggers\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;receive_http_message\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Receive HTTP Message\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;port\u0026#34;: \u0026#34;9234\u0026#34; }, \u0026#34;handlers\u0026#34;: [ { \u0026#34;settings\u0026#34;: { \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/filter/:val\u0026#34; }, \u0026#34;action\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;simple_filter\u0026#34;, \u0026#34;mappings\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;mapTo\u0026#34;: \u0026#34;input\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;assign\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$.pathParams.val\u0026#34; } ] } } } ] } ], \u0026#34;actions\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;simple_filter\u0026#34;, \u0026#34;ref\u0026#34;: \u0026#34;github.com/project-flogo/stream\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;pipelineURI\u0026#34;: \u0026#34;res://pipeline:simple_filter\u0026#34; } } ], \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;pipeline:simple_filter\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;metadata\u0026#34;: { \u0026#34;input\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;input\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } ] }, \u0026#34;stages\u0026#34;: [ { \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/activity/filter\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;non-zero\u0026#34;, \u0026#34;proceedOnlyOnEmit\u0026#34;: true }, \u0026#34;input\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;=$.input\u0026#34; } }, { \u0026#34;ref\u0026#34;: \u0026#34;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026#34;, \u0026#34;input\u0026#34;: { \u0026#34;message\u0026#34;: \u0026#34;=$.value\u0026#34; } } ] } } ] } Step 3: Install dependencies In your app, you\u0026rsquo;re making use of a few external dependencies that you need to install into your app for the Go compiler to be able to successfully build the app. To install external dependencies, you need to run\nflogo install \u0026lt;dependency location\u0026gt; So in the case of this tutorial, you\u0026rsquo;ll need to run\nflogo install github.com/project-flogo/stream flogo install github.com/TIBCOSoftware/flogo-lib/app/resource flogo install github.com/TIBCOSoftware/flogo-contrib/activity/filter Step 4: Build the app The next step is to build the executable. To build a flogo app from the source you can execute the command flogo build -e, which tells the flogo cli to build the app (and place it in a bin directory) and embed all configuration into a single executable\nflogo build -e Step 5: Run To run the app you just built, open a terminal and run\ncd bin ./streamfilter You can send commands to it using cURL and sending values that are non-zero should result in a log message. Events with a value of 0, will not result in a log message.\ncurl --request GET --url http://localhost:9234/filter/1 curl --request GET --url http://localhost:9234/filter/0 curl --request GET --url http://localhost:9234/filter/1 The above requests will result in the log activity being executed only twice\n2018-10-04 08:16:46.048 INFO [engine] - Engine Starting... 2018-10-04 08:16:46.049 INFO [engine] - Starting Services... 2018-10-04 08:16:46.049 INFO [engine] - Started Services 2018-10-04 08:16:46.049 INFO [engine] - Starting Triggers... 2018-10-04 08:16:46.050 INFO [engine] - Trigger [ receive_http_message ]: Started 2018-10-04 08:16:46.050 INFO [engine] - Triggers Started 2018-10-04 08:16:46.050 INFO [engine] - Engine Started 2018-10-04 08:16:51.514 INFO [trigger-flogo-rest] - Received request for id \u0026#39;receive_http_message\u0026#39; 2018-10-04 08:16:51.515 INFO [activity-flogo-log] - 1 2018-10-04 08:16:51.530 INFO [trigger-flogo-rest] - Received request for id \u0026#39;receive_http_message\u0026#39; 2018-10-04 08:16:51.545 INFO [trigger-flogo-rest] - Received request for id \u0026#39;receive_http_message\u0026#39; 2018-10-04 08:16:51.545 INFO [activity-flogo-log] - 1 "
},
{
	"uri": "https://tibcosoftware.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]